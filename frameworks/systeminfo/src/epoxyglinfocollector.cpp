/*
 * Copyright (c) 2005-2025, Kishonti Ltd
 * SPDX-License-Identifier: BSD-3-Clause
 * This file is part of GFXBench. See the top-level LICENSE file for details.
 */
#include "glinfocollector.h"
#include "ng/macro_utils.h"
#include "ng/log.h"
#include "ng/require.h"
#include "semver.h"
#include <iterator>
#include <sstream>
#include <algorithm>

#include <epoxy/egl.h>
#include <epoxy/gl.h>

#ifdef HAVE_GLFW3
#include "graphics/glformat.h"
#include "graphics/glfwgraphicscontext.h"
#include "graphics/glfwgraphicswindow.h"
#endif

#include "graphics/eglgraphicscontext.h"
#include "schemas/apidefinition.h"


#if __APPLE__
#include <TargetConditionals.h>
#   if TARGET_OS_IPHONE
#   import <OpenGLES/EAGL.h>
#   endif
#else
#define TARGET_OS_IPHONE 0
#endif

using namespace sysinf;



namespace
{
    NG_TABLE_START(TBL_EGL_ERROR)
        NG_TABLE_ITEM0(EGL_SUCCESS)
        NG_TABLE_ITEM0(EGL_SUCCESS)
        NG_TABLE_ITEM0(EGL_NOT_INITIALIZED)
        NG_TABLE_ITEM0(EGL_BAD_ACCESS)
        NG_TABLE_ITEM0(EGL_BAD_ALLOC)
        NG_TABLE_ITEM0(EGL_BAD_ATTRIBUTE)
        NG_TABLE_ITEM0(EGL_BAD_CONFIG)
        NG_TABLE_ITEM0(EGL_BAD_CONTEXT)
        NG_TABLE_ITEM0(EGL_BAD_CURRENT_SURFACE)
        NG_TABLE_ITEM0(EGL_BAD_DISPLAY)
        NG_TABLE_ITEM0(EGL_BAD_MATCH)
        NG_TABLE_ITEM0(EGL_BAD_NATIVE_PIXMAP)
        NG_TABLE_ITEM0(EGL_BAD_NATIVE_WINDOW)
        NG_TABLE_ITEM0(EGL_BAD_PARAMETER)
        NG_TABLE_ITEM0(EGL_BAD_SURFACE)
        NG_TABLE_ITEM0(EGL_CONTEXT_LOST)
    NG_TABLE_END(TBL_EGL_ERROR)

    NG_TABLE_START(TBL_CONFIG_ATTRS)
        NG_TABLE_ITEM0(EGL_ALPHA_SIZE)
        NG_TABLE_ITEM0(EGL_ALPHA_MASK_SIZE)
        NG_TABLE_ITEM0(EGL_BIND_TO_TEXTURE_RGB)
        NG_TABLE_ITEM0(EGL_BIND_TO_TEXTURE_RGBA)
        NG_TABLE_ITEM0(EGL_BLUE_SIZE)
        NG_TABLE_ITEM0(EGL_BUFFER_SIZE)
        NG_TABLE_ITEM0(EGL_COLOR_BUFFER_TYPE)
        NG_TABLE_ITEM0(EGL_CONFIG_CAVEAT)
        NG_TABLE_ITEM0(EGL_CONFIG_ID)
        NG_TABLE_ITEM0(EGL_CONFORMANT)
        NG_TABLE_ITEM0(EGL_DEPTH_SIZE)
        NG_TABLE_ITEM0(EGL_GREEN_SIZE)
        NG_TABLE_ITEM0(EGL_LEVEL)
        NG_TABLE_ITEM0(EGL_LUMINANCE_SIZE)
        NG_TABLE_ITEM0(EGL_MAX_PBUFFER_WIDTH)
        NG_TABLE_ITEM0(EGL_MAX_PBUFFER_HEIGHT)
        NG_TABLE_ITEM0(EGL_MAX_PBUFFER_PIXELS)
        NG_TABLE_ITEM0(EGL_MAX_SWAP_INTERVAL)
        NG_TABLE_ITEM0(EGL_MIN_SWAP_INTERVAL)
        NG_TABLE_ITEM0(EGL_NATIVE_RENDERABLE)
        NG_TABLE_ITEM0(EGL_NATIVE_VISUAL_ID)
        NG_TABLE_ITEM0(EGL_NATIVE_VISUAL_TYPE)
        NG_TABLE_ITEM0(EGL_RED_SIZE)
        NG_TABLE_ITEM0(EGL_RENDERABLE_TYPE)
        NG_TABLE_ITEM0(EGL_SAMPLE_BUFFERS)
        NG_TABLE_ITEM0(EGL_SAMPLES)
        NG_TABLE_ITEM0(EGL_STENCIL_SIZE)
        NG_TABLE_ITEM0(EGL_SURFACE_TYPE)
        NG_TABLE_ITEM0(EGL_TRANSPARENT_TYPE)
        NG_TABLE_ITEM0(EGL_TRANSPARENT_RED_VALUE)
        NG_TABLE_ITEM0(EGL_TRANSPARENT_GREEN_VALUE)
        NG_TABLE_ITEM0(EGL_TRANSPARENT_BLUE_VALUE)
    NG_TABLE_END(TBL_CONFIG_ATTRS)

    NG_TABLE_START(TBL_COLOR_BUFFER_TYPE)
        NG_TABLE_ITEM0(EGL_RGB_BUFFER)
        NG_TABLE_ITEM0(EGL_LUMINANCE_BUFFER)
    NG_TABLE_END(TBL_COLOR_BUFFER_TYPE)

    NG_TABLE_START(TBL_CONFIG_CAVEAT)
        NG_TABLE_ITEM0(EGL_NONE)
        NG_TABLE_ITEM0(EGL_SLOW_CONFIG)
        NG_TABLE_ITEM0(EGL_NON_CONFORMANT_CONFIG)
    NG_TABLE_END(TBL_CONFIG_CAVEAT)

    NG_TABLE_START(TBL_CONFORMANT)
        NG_TABLE_ITEM0(EGL_OPENGL_BIT)
        NG_TABLE_ITEM0(EGL_OPENGL_ES_BIT)
        NG_TABLE_ITEM0(EGL_OPENGL_ES2_BIT)
        NG_TABLE_ITEM0(EGL_OPENVG_BIT)
        NG_TABLE_ITEM0(EGL_OPENGL_ES3_BIT)
    NG_TABLE_END(TBL_CONFORMANT)

    NG_TABLE_START(TBL_SURFACE_TYPE)
        NG_TABLE_ITEM0(EGL_MULTISAMPLE_RESOLVE_BOX_BIT)
        NG_TABLE_ITEM0(EGL_PBUFFER_BIT)
        NG_TABLE_ITEM0(EGL_PIXMAP_BIT)
        NG_TABLE_ITEM0(EGL_SWAP_BEHAVIOR_PRESERVED_BIT)
        NG_TABLE_ITEM0(EGL_VG_ALPHA_FORMAT_PRE_BIT)
        NG_TABLE_ITEM0(EGL_VG_COLORSPACE_LINEAR_BIT)
        NG_TABLE_ITEM0(EGL_WINDOW_BIT)
        NG_TABLE_ITEM0(EGL_VG_COLORSPACE_LINEAR_BIT)
        NG_TABLE_ITEM0(EGL_VG_ALPHA_FORMAT_PRE_BIT)
        NG_TABLE_ITEM0(EGL_LOCK_SURFACE_BIT_KHR)
        NG_TABLE_ITEM0(EGL_OPTIMAL_FORMAT_BIT_KHR)
    NG_TABLE_END(TBL_SURFACE_TYPE)

    NG_TABLE_START(TBL_TRANSPARENT_TYPE)
        NG_TABLE_ITEM0(EGL_NONE)
        NG_TABLE_ITEM0(EGL_TRANSPARENT_RGB)
    NG_TABLE_END(TBL_TRANSPARENT_TYPE)

    NG_TABLE_START(TBL_BINARY_FORMATS)
        NG_TABLE_ITEM0(GL_Z400_BINARY_AMD)
        NG_TABLE_ITEM0(GL_SGX_BINARY_IMG)
        NG_TABLE_ITEM0(GL_MALI_SHADER_BINARY_ARM)
        NG_TABLE_ITEM0(GL_MALI_PROGRAM_BINARY_ARM)
        NG_TABLE_ITEM0(GL_SHADER_BINARY_VIV)
        NG_TABLE_ITEM0(GL_SGX_PROGRAM_BINARY_IMG)
        NG_TABLE_ITEM0(GL_SHADER_BINARY_DMP)
        NG_TABLE_ITEM0(GL_GCCSO_SHADER_BINARY_FJ)
        NG_TABLE_ITEM0(GL_PROGRAM_BINARY_ANGLE)
    NG_TABLE_END(TBL_BINARY_FORMATS)

    NG_TABLE_START(TBL_COMPRESSED_TEXTURE_FORMATS)
        NG_TABLE_ITEM0(GL_COMPRESSED_RED)
        NG_TABLE_ITEM0(GL_COMPRESSED_RG)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGB_S3TC_DXT1_EXT)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_S3TC_DXT1_EXT)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_S3TC_DXT3_EXT)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_S3TC_DXT5_EXT)
        NG_TABLE_ITEM0(GL_COMPRESSED_ALPHA)
        NG_TABLE_ITEM0(GL_COMPRESSED_ALPHA_ARB)
        NG_TABLE_ITEM0(GL_COMPRESSED_LUMINANCE)
        NG_TABLE_ITEM0(GL_COMPRESSED_LUMINANCE_ARB)
        NG_TABLE_ITEM0(GL_COMPRESSED_LUMINANCE_ALPHA)
        NG_TABLE_ITEM0(GL_COMPRESSED_LUMINANCE_ALPHA_ARB)
        NG_TABLE_ITEM0(GL_COMPRESSED_INTENSITY)
        NG_TABLE_ITEM0(GL_COMPRESSED_INTENSITY_ARB)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGB)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGB_ARB)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_ARB)
        NG_TABLE_ITEM0(GL_COMPRESSED_TEXTURE_FORMATS)
        NG_TABLE_ITEM0(GL_COMPRESSED_TEXTURE_FORMATS_ARB)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGB_FXT1_3DFX)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_FXT1_3DFX)
        NG_TABLE_ITEM0(GL_COMPRESSED_LUMINANCE_ALPHA_3DC_ATI)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB_PVRTC_2BPPV1_EXT)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB_PVRTC_4BPPV1_EXT)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV1_EXT)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV1_EXT)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB_EXT)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB_ALPHA)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB_ALPHA_EXT)
        NG_TABLE_ITEM0(GL_COMPRESSED_SLUMINANCE)
        NG_TABLE_ITEM0(GL_COMPRESSED_SLUMINANCE_EXT)
        NG_TABLE_ITEM0(GL_COMPRESSED_SLUMINANCE_ALPHA)
        NG_TABLE_ITEM0(GL_COMPRESSED_SLUMINANCE_ALPHA_EXT)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB_S3TC_DXT1_EXT)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB_S3TC_DXT1_NV)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_NV)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_NV)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_NV)
        NG_TABLE_ITEM0(GL_COMPRESSED_LUMINANCE_LATC1_EXT)
        NG_TABLE_ITEM0(GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT)
        NG_TABLE_ITEM0(GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT)
        NG_TABLE_ITEM0(GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT)
        NG_TABLE_ITEM0(GL_COMPRESSED_RED_RGTC1)
        NG_TABLE_ITEM0(GL_COMPRESSED_RED_RGTC1_EXT)
        NG_TABLE_ITEM0(GL_COMPRESSED_SIGNED_RED_RGTC1)
        NG_TABLE_ITEM0(GL_COMPRESSED_SIGNED_RED_RGTC1_EXT)
        NG_TABLE_ITEM0(GL_COMPRESSED_RED_GREEN_RGTC2_EXT)
        NG_TABLE_ITEM0(GL_COMPRESSED_RG_RGTC2)
        NG_TABLE_ITEM0(GL_COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT)
        NG_TABLE_ITEM0(GL_COMPRESSED_SIGNED_RG_RGTC2)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_BPTC_UNORM)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_BPTC_UNORM_ARB)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_PVRTC_2BPPV2_IMG)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_PVRTC_4BPPV2_IMG)
        NG_TABLE_ITEM0(GL_COMPRESSED_R11_EAC)
        NG_TABLE_ITEM0(GL_COMPRESSED_R11_EAC_OES)
        NG_TABLE_ITEM0(GL_COMPRESSED_SIGNED_R11_EAC)
        NG_TABLE_ITEM0(GL_COMPRESSED_SIGNED_R11_EAC_OES)
        NG_TABLE_ITEM0(GL_COMPRESSED_RG11_EAC)
        NG_TABLE_ITEM0(GL_COMPRESSED_RG11_EAC_OES)
        NG_TABLE_ITEM0(GL_COMPRESSED_SIGNED_RG11_EAC)
        NG_TABLE_ITEM0(GL_COMPRESSED_SIGNED_RG11_EAC_OES)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGB8_ETC2)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGB8_ETC2_OES)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_ETC2)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_ETC2_OES)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2_OES)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2_OES)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA8_ETC2_EAC)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA8_ETC2_EAC_OES)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC_OES)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_ASTC_4x4_KHR)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_ASTC_5x4_KHR)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_ASTC_5x5_KHR)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_ASTC_6x5_KHR)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_ASTC_6x6_KHR)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_ASTC_8x5_KHR)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_ASTC_8x6_KHR)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_ASTC_8x8_KHR)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_ASTC_10x5_KHR)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_ASTC_10x6_KHR)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_ASTC_10x8_KHR)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_ASTC_10x10_KHR)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_ASTC_12x10_KHR)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_ASTC_12x12_KHR)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_ASTC_3x3x3_OES)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_ASTC_4x3x3_OES)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_ASTC_4x4x3_OES)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_ASTC_4x4x4_OES)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_ASTC_5x4x4_OES)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_ASTC_5x5x4_OES)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_ASTC_5x5x5_OES)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_ASTC_6x5x5_OES)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_ASTC_6x6x5_OES)
        NG_TABLE_ITEM0(GL_COMPRESSED_RGBA_ASTC_6x6x6_OES)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3_OES)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3_OES)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3_OES)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4_OES)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4_OES)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4_OES)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5_OES)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5_OES)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5_OES)
        NG_TABLE_ITEM0(GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6_OES)

        NG_TABLE_ITEM0(GL_ETC1_RGB8_OES)
        NG_TABLE_ITEM0(GL_3DC_X_AMD)
        NG_TABLE_ITEM0(GL_3DC_XY_AMD)
        NG_TABLE_ITEM0(GL_ATC_RGB_AMD)
        NG_TABLE_ITEM0(GL_ATC_RGBA_EXPLICIT_ALPHA_AMD)
        NG_TABLE_ITEM0(GL_ATC_RGBA_INTERPOLATED_ALPHA_AMD)
        NG_TABLE_ITEM0(GL_PALETTE4_RGB8_OES)
        NG_TABLE_ITEM0(GL_PALETTE4_RGBA8_OES)
        NG_TABLE_ITEM0(GL_PALETTE4_R5_G6_B5_OES)
        NG_TABLE_ITEM0(GL_PALETTE4_RGBA4_OES)
        NG_TABLE_ITEM0(GL_PALETTE4_RGB5_A1_OES)
        NG_TABLE_ITEM0(GL_PALETTE8_RGB8_OES)
        NG_TABLE_ITEM0(GL_PALETTE8_RGBA8_OES)
        NG_TABLE_ITEM0(GL_PALETTE8_R5_G6_B5_OES)
        NG_TABLE_ITEM0(GL_PALETTE8_RGBA4_OES)
        NG_TABLE_ITEM0(GL_PALETTE8_RGB5_A1_OES)
        NG_TABLE_ITEM0(GL_RGBA_DXT5_S3TC)
        NG_TABLE_ITEM0(GL_RGBA4_DXT5_S3TC)
    NG_TABLE_END(TBL_COMPRESSED_TEXTURE_FORMATS)

    NG_TABLE_START(TBL_COLOR_READ_TYPE)
        // GLES 2.0
        NG_TABLE_ITEM0(GL_UNSIGNED_BYTE)
        NG_TABLE_ITEM0(GL_UNSIGNED_SHORT_5_6_5)
        NG_TABLE_ITEM0(GL_UNSIGNED_SHORT_4_4_4_4)
        NG_TABLE_ITEM0(GL_UNSIGNED_SHORT_5_5_5_1)
        // GLES 3.1
        NG_TABLE_ITEM0(GL_UNSIGNED_BYTE)
        NG_TABLE_ITEM0(GL_UNSIGNED_INT)
        NG_TABLE_ITEM0(GL_UNSIGNED_INT_2_10_10_10_REV)
        NG_TABLE_ITEM0(GL_INT)
        NG_TABLE_ITEM0(GL_FLOAT)
    NG_TABLE_END(TBL_COLOR_READ_TYPE)

    NG_TABLE_START(TBL_COLOR_READ_FORMAT)
        // GLES 2.0
        NG_TABLE_ITEM0(GL_ALPHA)
        NG_TABLE_ITEM0(GL_RGB)
        NG_TABLE_ITEM0(GL_RGBA)
        // GLES 3.1
        NG_TABLE_ITEM0(GL_RED)
        NG_TABLE_ITEM0(GL_RED_INTEGER)
        NG_TABLE_ITEM0(GL_RG)
        NG_TABLE_ITEM0(GL_RG_INTEGER)
        NG_TABLE_ITEM0(GL_RGB)
        NG_TABLE_ITEM0(GL_RGB_INTEGER)
        NG_TABLE_ITEM0(GL_RGBA)
        NG_TABLE_ITEM0(GL_RGBA_INTEGER)
        NG_TABLE_ITEM0(GL_LUMINANCE_ALPHA)
        NG_TABLE_ITEM0(GL_LUMINANCE)
        NG_TABLE_ITEM0(GL_ALPHA)
        // others
        NG_TABLE_ITEM0(GL_BGR)
        NG_TABLE_ITEM0(GL_BGRA)
    NG_TABLE_END(TBL_COLOR_READ_FORMAT)

#if !TARGET_OS_IPHONE
    EGLint getConfigAttrib(EGLDisplay dpy, EGLConfig cfg, EGLint attr)
    {
        EGLint value = -1;
        EGLint status = eglGetConfigAttrib(dpy, cfg, attr, &value);
        if (status != EGL_TRUE)
        {
            EGLenum err = eglGetError();
            if (err == EGL_BAD_ATTRIBUTE)
            {
                //NGLOG_WARN("EGL_BAD_ATTRIBUTE generated for attr: %s", TBL_CONFIG_ATTRS(attr));
            }
            else
            {
                std::ostringstream os;
                os << "eglGetConfigAttrib generated: " << TBL_EGL_ERROR(err);
                throw std::runtime_error(os.str());
            }
        }
        return value;
    }

    void collectEGLConfigInfo(EGLDisplay dpy, std::vector<EGLConfigInfo> &configInfos)
    {
        std::vector<EGLConfig> configs;
        int32_t numConfigs = 0;
        if (eglGetConfigs(dpy, 0, 0, &numConfigs))
        {
            configs.resize(numConfigs);
            eglGetConfigs(dpy, configs.data(), numConfigs, &numConfigs);
        }
        for (size_t i = 0; i < configs.size(); ++i)
        {
            EGLConfig &cfg = configs[i];
            EGLConfigInfo c;
            c.alphaSize = getConfigAttrib(dpy, cfg, EGL_ALPHA_SIZE);
            c.alphaMaskSize = getConfigAttrib(dpy, cfg, EGL_ALPHA_MASK_SIZE);
            c.bindToTextureRgb = getConfigAttrib(dpy, cfg, EGL_BIND_TO_TEXTURE_RGB) == EGL_TRUE;
            c.bindToTextureRgba = getConfigAttrib(dpy, cfg, EGL_BIND_TO_TEXTURE_RGBA) == EGL_TRUE;
            c.blueSize = getConfigAttrib(dpy, cfg, EGL_BLUE_SIZE);
            c.bufferSize = getConfigAttrib(dpy, cfg, EGL_BUFFER_SIZE);
            c.colorBufferType = TBL_COLOR_BUFFER_TYPE(getConfigAttrib(dpy, cfg, EGL_COLOR_BUFFER_TYPE));
            c.configCaveat = TBL_CONFIG_CAVEAT(getConfigAttrib(dpy, cfg, EGL_CONFIG_CAVEAT));
            c.configId = getConfigAttrib(dpy, cfg, EGL_CONFIG_ID);
            c.conformant = TBL_CONFORMANT.bitmask(getConfigAttrib(dpy, cfg, EGL_CONFORMANT));
            c.depthSize = getConfigAttrib(dpy, cfg, EGL_DEPTH_SIZE);
            c.greenSize = getConfigAttrib(dpy, cfg, EGL_GREEN_SIZE);
            c.level = getConfigAttrib(dpy, cfg, EGL_LEVEL);
            c.luminanceSize = getConfigAttrib(dpy, cfg, EGL_LUMINANCE_SIZE);
            c.maxPBufferWidth = getConfigAttrib(dpy, cfg, EGL_MAX_PBUFFER_WIDTH);
            c.maxPBufferHeight = getConfigAttrib(dpy, cfg, EGL_MAX_PBUFFER_HEIGHT);
            c.maxPBufferPixels = getConfigAttrib(dpy, cfg, EGL_MAX_PBUFFER_PIXELS);
            c.maxSwapInterval = getConfigAttrib(dpy, cfg, EGL_MAX_SWAP_INTERVAL);
            c.minSwapInterval = getConfigAttrib(dpy, cfg, EGL_MIN_SWAP_INTERVAL);
            c.nativeRenderable = getConfigAttrib(dpy, cfg, EGL_NATIVE_RENDERABLE) == EGL_TRUE;
            c.nativeVisualId = getConfigAttrib(dpy, cfg, EGL_NATIVE_VISUAL_ID);
            c.nativeVisualType = getConfigAttrib(dpy, cfg, EGL_NATIVE_VISUAL_TYPE);
            c.redSize = getConfigAttrib(dpy, cfg, EGL_RED_SIZE);
            c.renderableType = TBL_CONFORMANT.bitmask(getConfigAttrib(dpy, cfg, EGL_RENDERABLE_TYPE));
            c.sampleBuffers = getConfigAttrib(dpy, cfg, EGL_SAMPLE_BUFFERS);
            c.samples = getConfigAttrib(dpy, cfg, EGL_SAMPLES);
            c.stencilSize = getConfigAttrib(dpy, cfg, EGL_STENCIL_SIZE);
            c.surfaceType = TBL_SURFACE_TYPE.bitmask(getConfigAttrib(dpy, cfg, EGL_SURFACE_TYPE));
            c.transparentType = TBL_TRANSPARENT_TYPE(getConfigAttrib(dpy, cfg, EGL_TRANSPARENT_TYPE));
            c.transparentRedValue = getConfigAttrib(dpy, cfg, EGL_TRANSPARENT_RED_VALUE);
            c.transparentGreenValue = getConfigAttrib(dpy, cfg, EGL_TRANSPARENT_GREEN_VALUE);
            c.transparentBlueValue = getConfigAttrib(dpy, cfg, EGL_TRANSPARENT_BLUE_VALUE);
            configInfos.push_back(c);
        }
    }
#endif
}



#define ADD_ITEM(X) gles.maxi.push_back(std::make_pair(#X,geti(X)))
#define ADD_ITEM64(X) gles.maxi.push_back(std::make_pair(#X,geti64(X)))
#define CHECK_GL(X) { X; GLint __check_err = glGetError(); if (__check_err) { NGLOG_ERROR("%s generated: %s", #X, __check_err); } }



namespace detail
{
    int64_t geti64(GLenum e)
    {
        int64_t v = -1;
        CHECK_GL(glGetInteger64v(e, &v));
        return v;
    }

    int32_t geti(GLenum e)
    {
        int32_t v = -1;
        CHECK_GL(glGetIntegerv(e, &v));
        return v;
    }

    std::string getstr(GLenum e)
    {
        const unsigned char* str;
        CHECK_GL(str = glGetString(e));
        return (str != nullptr) ? std::string(reinterpret_cast<const char*>(str)) : std::string();
    }

    std::string getstri(GLenum e, int i)
    {
        const unsigned char* str;
        CHECK_GL(str = glGetStringi(e, i));
        return (str != nullptr) ? std::string(reinterpret_cast<const char*>(str)) : std::string();
    }

    std::vector<std::string> getsv(GLenum num, GLenum query, const ng::macro_utils::Table &tbl)
    {
        int32_t n = -1;
        std::vector<std::string> sv;
        CHECK_GL(glGetIntegerv(num, &n));
        if (n > 0)
        {
            std::vector<int32_t> v(n);
            CHECK_GL(glGetIntegerv(query, v.data()));
            for (int i = 0; i < n; ++i)
            {
                sv.push_back(tbl(v[i]));
            }
        }
        return sv;
    }

    void queryCommon(GLESInfo &gles)
    {
        gles.vendor = getstr(GL_VENDOR);
        gles.version = getstr(GL_VERSION);
        gles.renderer = getstr(GL_RENDERER);
        tfw::ApiDefinition apiDefinition;
        apiDefinition.fromVersionString(gles.version);
        gles.majorVersion = apiDefinition.major();
        gles.minorVersion = apiDefinition.minor();

        std::vector<std::string> extensions;
        /* Fortunately this condition works both on desktop and in GLES. */
        if (gles.majorVersion >= 3) {
            int32_t numExtensions = 0;
            glGetIntegerv(GL_NUM_EXTENSIONS, &numExtensions);
            for (int i = 0; i < numExtensions; ++i) {
                gles.extensions.push_back(getstri(GL_EXTENSIONS, i));
            }
        } else {
            std::istringstream ext(getstr(GL_EXTENSIONS));
            std::copy(std::istream_iterator<std::string>(ext),
                std::istream_iterator<std::string>(),
                std::back_inserter <std::vector<std::string> >(gles.extensions));
        }
        std::sort(gles.extensions.begin(), gles.extensions.end());
    }

    void nullQuery(GLESInfo&) {}

    void queryGL11(GLESInfo& gles)
    {
        ADD_ITEM(GL_MAX_TEXTURE_SIZE);
        ADD_ITEM(GL_MAX_LIST_NESTING);
        ADD_ITEM(GL_MAX_EVAL_ORDER);
        ADD_ITEM(GL_MAX_LIGHTS);
        ADD_ITEM(GL_MAX_CLIP_PLANES);
        ADD_ITEM(GL_MAX_PIXEL_MAP_TABLE);
        ADD_ITEM(GL_MAX_ATTRIB_STACK_DEPTH);
        ADD_ITEM(GL_MAX_MODELVIEW_STACK_DEPTH);
        ADD_ITEM(GL_MAX_NAME_STACK_DEPTH);
        ADD_ITEM(GL_MAX_PROJECTION_STACK_DEPTH);
        ADD_ITEM(GL_MAX_TEXTURE_STACK_DEPTH);
        ADD_ITEM(GL_MAX_CLIENT_ATTRIB_STACK_DEPTH);
        ADD_ITEM(GL_ALPHA_BITS);
        ADD_ITEM(GL_BLUE_BITS);
        ADD_ITEM(GL_DEPTH_BITS);
        ADD_ITEM(GL_GREEN_BITS);
        ADD_ITEM(GL_RED_BITS);
        ADD_ITEM(GL_STENCIL_BITS);

        glGetIntegerv(GL_MAX_VIEWPORT_DIMS, gles.maxViewportDims);
    }

    void queryGL12(GLESInfo& gles)
    {
        ADD_ITEM(GL_MAX_3D_TEXTURE_SIZE);
        ADD_ITEM(GL_MAX_ELEMENTS_VERTICES);
        ADD_ITEM(GL_MAX_ELEMENTS_INDICES);

        glGetIntegerv(GL_ALIASED_LINE_WIDTH_RANGE, gles.aliasedLineWidthRange);
        glGetIntegerv(GL_ALIASED_POINT_SIZE_RANGE, gles.aliasedPointSizeRange);
    }

    void queryGL13(GLESInfo& gles)
    {
        ADD_ITEM(GL_MAX_CUBE_MAP_TEXTURE_SIZE);
        ADD_ITEM(GL_MAX_TEXTURE_UNITS);

        gles.compressedTextureFormats = getsv(GL_NUM_COMPRESSED_TEXTURE_FORMATS,
                GL_COMPRESSED_TEXTURE_FORMATS, TBL_COMPRESSED_TEXTURE_FORMATS);
    }

    void queryGL14(GLESInfo& gles)
    {
        ADD_ITEM(GL_MAX_TEXTURE_LOD_BIAS);
    }

    void queryGL20(GLESInfo& gles)
    {
        ADD_ITEM(GL_MAX_DRAW_BUFFERS);
        ADD_ITEM(GL_MAX_VERTEX_ATTRIBS);
        ADD_ITEM(GL_MAX_TEXTURE_IMAGE_UNITS);
        ADD_ITEM(GL_MAX_FRAGMENT_UNIFORM_COMPONENTS);
        ADD_ITEM(GL_MAX_VERTEX_UNIFORM_COMPONENTS);
        ADD_ITEM(GL_MAX_VARYING_FLOATS);
        ADD_ITEM(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS);
        ADD_ITEM(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        ADD_ITEM(GL_MAX_TEXTURE_COORDS);

        gles.shadingLanguageVersion = getstr(GL_SHADING_LANGUAGE_VERSION);
    }

    void queryGL30(GLESInfo& gles)
    {
        ADD_ITEM(GL_MAJOR_VERSION);
        ADD_ITEM(GL_MINOR_VERSION);
        ADD_ITEM(GL_MAX_CLIP_DISTANCES);
        ADD_ITEM(GL_MAX_ARRAY_TEXTURE_LAYERS);
        ADD_ITEM(GL_MAX_PROGRAM_TEXEL_OFFSET);
        ADD_ITEM(GL_MAX_VARYING_COMPONENTS);
        ADD_ITEM(GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS);
        ADD_ITEM(GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS);
        ADD_ITEM(GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS);
        ADD_ITEM(GL_MAX_RENDERBUFFER_SIZE);
        ADD_ITEM(GL_MAX_COLOR_ATTACHMENTS);
        ADD_ITEM(GL_MAX_SAMPLES);
    }

    void queryGL31(GLESInfo& gles)
    {
        ADD_ITEM(GL_MAX_TEXTURE_BUFFER_SIZE);
        ADD_ITEM(GL_MAX_RECTANGLE_TEXTURE_SIZE);
        ADD_ITEM(GL_MAX_VERTEX_UNIFORM_BLOCKS);
        ADD_ITEM(GL_MAX_FRAGMENT_UNIFORM_BLOCKS);
        ADD_ITEM(GL_MAX_COMBINED_UNIFORM_BLOCKS);
        ADD_ITEM(GL_MAX_UNIFORM_BUFFER_BINDINGS);
        ADD_ITEM(GL_MAX_UNIFORM_BLOCK_SIZE);
        ADD_ITEM(GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS);
        ADD_ITEM(GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS);
    }

    void queryGL32(GLESInfo& gles)
    {
        ADD_ITEM64(GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS);
        ADD_ITEM64(GL_MAX_GEOMETRY_UNIFORM_COMPONENTS);
        ADD_ITEM64(GL_MAX_GEOMETRY_OUTPUT_VERTICES);
        ADD_ITEM64(GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS);
        ADD_ITEM64(GL_MAX_VERTEX_OUTPUT_COMPONENTS);
        ADD_ITEM64(GL_MAX_GEOMETRY_INPUT_COMPONENTS);
        ADD_ITEM64(GL_MAX_GEOMETRY_OUTPUT_COMPONENTS);
        ADD_ITEM64(GL_MAX_FRAGMENT_INPUT_COMPONENTS);
        ADD_ITEM64(GL_MAX_SERVER_WAIT_TIMEOUT);
        ADD_ITEM64(GL_MAX_SAMPLE_MASK_WORDS);
        ADD_ITEM64(GL_MAX_COLOR_TEXTURE_SAMPLES);
        ADD_ITEM64(GL_MAX_DEPTH_TEXTURE_SAMPLES);
        ADD_ITEM64(GL_MAX_INTEGER_SAMPLES);
        ADD_ITEM64(GL_MAX_LIST_NESTING);
        ADD_ITEM64(GL_MAX_EVAL_ORDER);
        ADD_ITEM64(GL_MAX_LIGHTS);
        ADD_ITEM64(GL_MAX_CLIP_PLANES);
        ADD_ITEM64(GL_MAX_PIXEL_MAP_TABLE);
        ADD_ITEM64(GL_MAX_ATTRIB_STACK_DEPTH);
        ADD_ITEM64(GL_MAX_MODELVIEW_STACK_DEPTH);
        ADD_ITEM64(GL_MAX_NAME_STACK_DEPTH);
        ADD_ITEM64(GL_MAX_PROJECTION_STACK_DEPTH);
        ADD_ITEM64(GL_MAX_TEXTURE_STACK_DEPTH);
        ADD_ITEM64(GL_MAX_CLIENT_ATTRIB_STACK_DEPTH);
        ADD_ITEM64(GL_MAX_TEXTURE_UNITS);
        ADD_ITEM64(GL_MAX_TEXTURE_COORDS);
    }

    void queryGL33(GLESInfo& gles)
    {
        ADD_ITEM64(GL_MAX_DUAL_SOURCE_DRAW_BUFFERS);
    }

    void queryGL40(GLESInfo& gles)
    {
        ADD_ITEM64(GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET);
        ADD_ITEM64(GL_MAX_GEOMETRY_SHADER_INVOCATIONS);
        ADD_ITEM64(GL_MAX_FRAGMENT_INTERPOLATION_OFFSET);
        ADD_ITEM64(GL_MAX_VERTEX_STREAMS);
        ADD_ITEM64(GL_MAX_SUBROUTINES);
        ADD_ITEM64(GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS);
        ADD_ITEM64(GL_MAX_PATCH_VERTICES);
        ADD_ITEM64(GL_MAX_TESS_GEN_LEVEL);
        ADD_ITEM64(GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS);
        ADD_ITEM64(GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS);
        ADD_ITEM64(GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS);
        ADD_ITEM64(GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS);
        ADD_ITEM64(GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS);
        ADD_ITEM64(GL_MAX_TESS_PATCH_COMPONENTS);
        ADD_ITEM64(GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS);
        ADD_ITEM64(GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS);
        ADD_ITEM64(GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS);
        ADD_ITEM64(GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS);
        ADD_ITEM64(GL_MAX_TESS_CONTROL_INPUT_COMPONENTS);
        ADD_ITEM64(GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS);
        ADD_ITEM64(GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS);
        ADD_ITEM64(GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS);
        ADD_ITEM64(GL_MAX_TRANSFORM_FEEDBACK_BUFFERS);
        ADD_ITEM64(GL_MAX_VERTEX_STREAMS);
    }

    void queryGL41(GLESInfo& gles)
    {
        ADD_ITEM64(GL_MAX_VERTEX_UNIFORM_VECTORS);
        ADD_ITEM64(GL_MAX_VARYING_VECTORS);
        ADD_ITEM64(GL_MAX_FRAGMENT_UNIFORM_VECTORS);
        ADD_ITEM64(GL_MAX_VIEWPORTS);

        gles.shaderCompiler = geti(GL_SHADER_COMPILER) != GL_FALSE;
        gles.implementationColorReadType =
                TBL_COLOR_READ_TYPE(geti(GL_IMPLEMENTATION_COLOR_READ_TYPE));
        gles.implementationColorReadFormat =
                TBL_COLOR_READ_FORMAT(geti(GL_IMPLEMENTATION_COLOR_READ_FORMAT));
        gles.programBinaryFormats = getsv(GL_NUM_PROGRAM_BINARY_FORMATS, GL_PROGRAM_BINARY_FORMATS,
                TBL_BINARY_FORMATS);
        gles.shaderBinaryFormats = getsv(GL_NUM_SHADER_BINARY_FORMATS, GL_SHADER_BINARY_FORMATS,
                TBL_BINARY_FORMATS);
    }

    void queryGL42(GLESInfo& gles)
    {
        ADD_ITEM64(GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS);
        ADD_ITEM64(GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS);
        ADD_ITEM64(GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS);
        ADD_ITEM64(GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS);
        ADD_ITEM64(GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS);
        ADD_ITEM64(GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS);
        ADD_ITEM64(GL_MAX_VERTEX_ATOMIC_COUNTERS);
        ADD_ITEM64(GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS);
        ADD_ITEM64(GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS);
        ADD_ITEM64(GL_MAX_GEOMETRY_ATOMIC_COUNTERS);
        ADD_ITEM64(GL_MAX_FRAGMENT_ATOMIC_COUNTERS);
        ADD_ITEM64(GL_MAX_COMBINED_ATOMIC_COUNTERS);
        ADD_ITEM64(GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE);
        ADD_ITEM64(GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS);
        ADD_ITEM64(GL_MAX_IMAGE_UNITS);
        ADD_ITEM64(GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS);
        ADD_ITEM64(GL_MAX_IMAGE_SAMPLES);
        ADD_ITEM64(GL_MAX_VERTEX_IMAGE_UNIFORMS);
        ADD_ITEM64(GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS);
        ADD_ITEM64(GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS);
        ADD_ITEM64(GL_MAX_GEOMETRY_IMAGE_UNIFORMS);
        ADD_ITEM64(GL_MAX_FRAGMENT_IMAGE_UNIFORMS);
        ADD_ITEM64(GL_MAX_COMBINED_IMAGE_UNIFORMS);
    }

    void queryGL43(GLESInfo& gles)
    {
        ADD_ITEM64(GL_MAX_ELEMENT_INDEX);
        ADD_ITEM64(GL_MAX_COMPUTE_UNIFORM_BLOCKS);
        ADD_ITEM64(GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS);
        ADD_ITEM64(GL_MAX_COMPUTE_IMAGE_UNIFORMS);
        ADD_ITEM64(GL_MAX_COMPUTE_SHARED_MEMORY_SIZE);
        ADD_ITEM64(GL_MAX_COMPUTE_UNIFORM_COMPONENTS);
        ADD_ITEM64(GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS);
        ADD_ITEM64(GL_MAX_COMPUTE_ATOMIC_COUNTERS);
        ADD_ITEM64(GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS);
        ADD_ITEM64(GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS);
        ADD_ITEM64(GL_MAX_DEBUG_MESSAGE_LENGTH);
        ADD_ITEM64(GL_MAX_DEBUG_LOGGED_MESSAGES);
        ADD_ITEM64(GL_MAX_DEBUG_GROUP_STACK_DEPTH);
        ADD_ITEM64(GL_MAX_LABEL_LENGTH);
        ADD_ITEM64(GL_MAX_UNIFORM_LOCATIONS);
        ADD_ITEM64(GL_MAX_FRAMEBUFFER_WIDTH);
        ADD_ITEM64(GL_MAX_FRAMEBUFFER_HEIGHT);
        ADD_ITEM64(GL_MAX_FRAMEBUFFER_LAYERS);
        ADD_ITEM64(GL_MAX_FRAMEBUFFER_SAMPLES);
        ADD_ITEM64(GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS);
        ADD_ITEM64(GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS);
        ADD_ITEM64(GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS);
        ADD_ITEM64(GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS);
        ADD_ITEM64(GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS);
        ADD_ITEM64(GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS);
        ADD_ITEM64(GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS);
        ADD_ITEM64(GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS);
        ADD_ITEM64(GL_MAX_SHADER_STORAGE_BLOCK_SIZE);
        ADD_ITEM64(GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES);
        ADD_ITEM64(GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET);
        ADD_ITEM64(GL_MAX_VERTEX_ATTRIB_BINDINGS);
        for (int i = 0; i < 3; ++i) {
            glGetIntegeri_v(GL_MAX_COMPUTE_WORK_GROUP_COUNT, i, &gles.maxComputeWorkGroupCount[i]);
            glGetIntegeri_v(GL_MAX_COMPUTE_WORK_GROUP_SIZE, i, &gles.maxComputeWorkGroupSize[i]);
        }
    }

    void queryGL44(GLESInfo& gles)
    {
        ADD_ITEM64(GL_MAX_VERTEX_ATTRIB_STRIDE);
    }



    void queryGLES20(GLESInfo& gles)
    {
        ADD_ITEM(GL_MAX_TEXTURE_SIZE);
        ADD_ITEM(GL_MAX_VERTEX_ATTRIBS);
        ADD_ITEM(GL_MAX_VERTEX_UNIFORM_VECTORS);
        ADD_ITEM(GL_MAX_VARYING_VECTORS);
        ADD_ITEM(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        ADD_ITEM(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS);
        ADD_ITEM(GL_MAX_TEXTURE_IMAGE_UNITS);
        ADD_ITEM(GL_MAX_FRAGMENT_UNIFORM_VECTORS);
        ADD_ITEM(GL_MAX_CUBE_MAP_TEXTURE_SIZE);
        ADD_ITEM(GL_MAX_RENDERBUFFER_SIZE);
        ADD_ITEM(GL_ALPHA_BITS);
        ADD_ITEM(GL_BLUE_BITS);
        ADD_ITEM(GL_DEPTH_BITS);
        ADD_ITEM(GL_GREEN_BITS);
        ADD_ITEM(GL_RED_BITS);
        ADD_ITEM(GL_STENCIL_BITS);

        glGetIntegerv(GL_ALIASED_LINE_WIDTH_RANGE, gles.aliasedLineWidthRange);
        glGetIntegerv(GL_ALIASED_POINT_SIZE_RANGE, gles.aliasedPointSizeRange);
        glGetIntegerv(GL_MAX_VIEWPORT_DIMS, gles.maxViewportDims);
        gles.implementationColorReadType =
                TBL_COLOR_READ_TYPE(geti(GL_IMPLEMENTATION_COLOR_READ_TYPE));
        gles.implementationColorReadFormat =
                TBL_COLOR_READ_FORMAT(geti(GL_IMPLEMENTATION_COLOR_READ_FORMAT));
        gles.shaderCompiler = geti(GL_SHADER_COMPILER) != GL_FALSE;
        gles.compressedTextureFormats = getsv(GL_NUM_COMPRESSED_TEXTURE_FORMATS,
                GL_COMPRESSED_TEXTURE_FORMATS, TBL_COMPRESSED_TEXTURE_FORMATS);
        gles.shaderBinaryFormats = getsv(GL_NUM_SHADER_BINARY_FORMATS, GL_SHADER_BINARY_FORMATS,
                TBL_BINARY_FORMATS);
    }

    void queryGLES30(GLESInfo& gles)
    {
        ADD_ITEM64(GL_MAJOR_VERSION);
        ADD_ITEM64(GL_MINOR_VERSION);
        ADD_ITEM64(GL_MAX_3D_TEXTURE_SIZE);
        ADD_ITEM64(GL_MAX_ELEMENTS_VERTICES);
        ADD_ITEM64(GL_MAX_ELEMENTS_INDICES);
        ADD_ITEM64(GL_MAX_TEXTURE_LOD_BIAS);
        ADD_ITEM64(GL_MAX_DRAW_BUFFERS);
        ADD_ITEM64(GL_MAX_FRAGMENT_UNIFORM_COMPONENTS);
        ADD_ITEM64(GL_MAX_VERTEX_UNIFORM_COMPONENTS);
        ADD_ITEM64(GL_MAX_ARRAY_TEXTURE_LAYERS);
        ADD_ITEM64(GL_MAX_PROGRAM_TEXEL_OFFSET);
        ADD_ITEM64(GL_MAX_VARYING_COMPONENTS);
        ADD_ITEM64(GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS);
        ADD_ITEM64(GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS);
        ADD_ITEM64(GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS);
        ADD_ITEM64(GL_MAX_COLOR_ATTACHMENTS);
        ADD_ITEM64(GL_MAX_SAMPLES);
        ADD_ITEM64(GL_MAX_VERTEX_UNIFORM_BLOCKS);
        ADD_ITEM64(GL_MAX_FRAGMENT_UNIFORM_BLOCKS);
        ADD_ITEM64(GL_MAX_COMBINED_UNIFORM_BLOCKS);
        ADD_ITEM64(GL_MAX_UNIFORM_BUFFER_BINDINGS);
        ADD_ITEM64(GL_MAX_UNIFORM_BLOCK_SIZE);
        ADD_ITEM64(GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS);
        ADD_ITEM64(GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS);
        ADD_ITEM64(GL_MAX_VERTEX_OUTPUT_COMPONENTS);
        ADD_ITEM64(GL_MAX_FRAGMENT_INPUT_COMPONENTS);
        ADD_ITEM64(GL_MAX_SERVER_WAIT_TIMEOUT);
        ADD_ITEM64(GL_MAX_ELEMENT_INDEX);

        ADD_ITEM64(GL_MIN_PROGRAM_TEXEL_OFFSET);

        gles.programBinaryFormats = getsv(GL_NUM_PROGRAM_BINARY_FORMATS, GL_PROGRAM_BINARY_FORMATS,
                TBL_BINARY_FORMATS);
        gles.shadingLanguageVersion = getstr(GL_SHADING_LANGUAGE_VERSION);
    }

    void queryGLES31(GLESInfo& gles)
    {
        ADD_ITEM64(GL_MAX_COMPUTE_UNIFORM_BLOCKS);
        ADD_ITEM64(GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS);
        ADD_ITEM64(GL_MAX_COMPUTE_IMAGE_UNIFORMS);
        ADD_ITEM64(GL_MAX_COMPUTE_SHARED_MEMORY_SIZE);
        ADD_ITEM64(GL_MAX_COMPUTE_UNIFORM_COMPONENTS);
        ADD_ITEM64(GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS);
        ADD_ITEM64(GL_MAX_COMPUTE_ATOMIC_COUNTERS);
        ADD_ITEM64(GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS);
        ADD_ITEM64(GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS);
        ADD_ITEM64(GL_MAX_UNIFORM_LOCATIONS);
        ADD_ITEM64(GL_MAX_FRAMEBUFFER_WIDTH);
        ADD_ITEM64(GL_MAX_FRAMEBUFFER_HEIGHT);
        ADD_ITEM64(GL_MAX_FRAMEBUFFER_SAMPLES);
        ADD_ITEM64(GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS);
        ADD_ITEM64(GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS);
        ADD_ITEM64(GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS);
        ADD_ITEM64(GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS);
        ADD_ITEM64(GL_MAX_VERTEX_ATOMIC_COUNTERS);
        ADD_ITEM64(GL_MAX_FRAGMENT_ATOMIC_COUNTERS);
        ADD_ITEM64(GL_MAX_COMPUTE_ATOMIC_COUNTERS);
        ADD_ITEM64(GL_MAX_COMBINED_ATOMIC_COUNTERS);
        ADD_ITEM64(GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE);
        ADD_ITEM64(GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS);
        ADD_ITEM64(GL_MAX_IMAGE_UNITS);
        ADD_ITEM64(GL_MAX_VERTEX_IMAGE_UNIFORMS);
        ADD_ITEM64(GL_MAX_FRAGMENT_IMAGE_UNIFORMS);
        ADD_ITEM64(GL_MAX_COMPUTE_IMAGE_UNIFORMS);
        ADD_ITEM64(GL_MAX_COMBINED_IMAGE_UNIFORMS);
        ADD_ITEM64(GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS);
        ADD_ITEM64(GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS);
        ADD_ITEM64(GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS);
        ADD_ITEM64(GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS);
        ADD_ITEM64(GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS);
        ADD_ITEM64(GL_MAX_SHADER_STORAGE_BLOCK_SIZE);
        ADD_ITEM64(GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES);
        ADD_ITEM64(GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET);
        ADD_ITEM64(GL_MAX_SAMPLE_MASK_WORDS);
        ADD_ITEM64(GL_MAX_COLOR_TEXTURE_SAMPLES);
        ADD_ITEM64(GL_MAX_DEPTH_TEXTURE_SAMPLES);
        ADD_ITEM64(GL_MAX_INTEGER_SAMPLES);
        ADD_ITEM64(GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET);
        ADD_ITEM64(GL_MAX_VERTEX_ATTRIB_BINDINGS);
        ADD_ITEM64(GL_MAX_VERTEX_ATTRIB_STRIDE);
        for (int i = 0; i < 3; ++i) {
            glGetIntegeri_v(GL_MAX_COMPUTE_WORK_GROUP_COUNT, i, &gles.maxComputeWorkGroupCount[i]);
            glGetIntegeri_v(GL_MAX_COMPUTE_WORK_GROUP_SIZE, i, &gles.maxComputeWorkGroupSize[i]);
        }
    }

    struct Version {
        int major;
        int minor;
        void(*query)(GLESInfo&);
    };



    void collectGl(GLESInfo& gl, bool& hasGl)
    {
#if defined(HAVE_GLFW3)
        if (!epoxy_is_gl_available()) {
            return;
        }
        using namespace detail;
        static const Version GL_VERSIONS[] = {
                { 1, 0, &nullQuery },
                { 1, 1, &queryGL11 },
                { 1, 2, &queryGL12 },
                { 1, 3, &queryGL13 },
                { 1, 4, &queryGL14 },
                { 1, 5, &nullQuery },
                { 2, 0, &queryGL20 },
                { 2, 1, &nullQuery },
                { 3, 0, &queryGL30 },
                { 3, 1, &queryGL31 },
                { 3, 2, &queryGL32 },
                { 3, 3, &queryGL33 },
                { 4, 0, &queryGL40 },
                { 4, 1, &queryGL41 },
                { 4, 2, &queryGL42 },
                { 4, 3, &queryGL43 },
                { 4, 4, &queryGL44 }
//                { 4, 5, &nullQuery }
        };
        static const size_t GL_VERSION_COUNT = sizeof(GL_VERSIONS) / sizeof(GL_VERSIONS[0]);

        for (ptrdiff_t i = GL_VERSION_COUNT - 1; (i >= 0) && !hasGl; --i) {
            const Version& version = GL_VERSIONS[i];
            try {
                GLFWGraphicsWindow window;
                window.setFormat(tfw::GLFormat(8, 8, 8, 0, 24, 0, 0, true));
#ifdef __APPLE__
                std::string contextType = "desktop_core";
#else
                std::string contextType = "desktop";
#endif
                window.create(256, 256, "glinfocollector", false, std::vector<tfw::ApiDefinition>(1,
                    tfw::ApiDefinition(tfw::ApiDefinition::GL, version.major, version.minor)),
                    contextType, true);
                GLFWGraphicsContext context(window.handle(), false);
                context.makeCurrent();
                queryCommon(gl);
                for (ptrdiff_t j = 0; j <= i; ++j) {
                    GL_VERSIONS[j].query(gl);
                }
                hasGl = true;
            } catch (const std::exception&) {
                /* Ignore */
            }
        }
        epoxy_gl_reinitialize_function_pointers();
#endif
    }



    void collectEgl(EGLInfo& egl, bool& hasEgl)
    {
#if !TARGET_OS_IPHONE
        if (!epoxy_is_egl_available()) {
            return;
        }

        EGLDisplay dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
        if (dpy == EGL_NO_DISPLAY) {
            NGLOG_INFO("No EGL display");
            return;
        }
        EGLint major, minor;
        EGLint status = eglInitialize(dpy, &major, &minor);
        if (status != EGL_TRUE) {
            NGLOG_INFO("Could not initialize EGL");
            return;
        }
        egl.vendor = eglQueryString(dpy, EGL_VENDOR);
        egl.version = eglQueryString(dpy, EGL_VERSION);
        collectEGLConfigInfo(dpy, egl.configs);

        std::istringstream clientApis(eglQueryString(dpy, EGL_CLIENT_APIS));
        std::copy(std::istream_iterator<std::string>(clientApis),
            std::istream_iterator<std::string>(),
            std::back_inserter <std::vector<std::string> >(egl.clientApis));
        std::sort(egl.clientApis.begin(), egl.clientApis.end());

        std::istringstream ext(eglQueryString(dpy, EGL_EXTENSIONS));
        std::copy(std::istream_iterator<std::string>(ext),
            std::istream_iterator<std::string>(),
            std::back_inserter <std::vector<std::string> >(egl.extensions));
        std::sort(egl.extensions.begin(), egl.extensions.end());
        eglTerminate(dpy);

        hasEgl = true;
#else
        hasEgl = false;
#endif
    }


#if !TARGET_OS_IPHONE
    void collectGles(SystemInfo& sysinf, GLESInfo& gles, bool& hasGles)
    {
        if (!epoxy_is_egl_available()) {
            NGLOG_INFO("epoxy_is_egl_available() returned false");
            return;
        }

        int androidVersonCode = 1;
        std::map<std::string, std::string>::iterator it = sysinf.osInfo.attributes.find("build_details/GLBPD_OS_BUILD_VERSION.SDK");
        if(it != sysinf.osInfo.attributes.end()) {
            androidVersonCode = atoi(it->second.c_str());
            NGLOG_INFO("androidVersonCode: %s", androidVersonCode);
        } else {
            androidVersonCode = 18; // We do not have android version code, so be sure to test all the GLES versions.
            NGLOG_INFO("androidVersonCode not found");
        }

        static const Version GLES_VERSIONS[] = {
            { 3, 1, &queryGLES31 },
            { 3, 0, &queryGLES30 },
            { 2, 0, &queryGLES20 }
        };
        static const size_t GLES_VERSION_COUNT = sizeof(GLES_VERSIONS) / sizeof(GLES_VERSIONS[0]);

        for (size_t i = 0; i < GLES_VERSION_COUNT && !hasGles; ++i) {
            const Version& version = GLES_VERSIONS[i];

            // Test against Android JELLY_BEAN_MR2 (Android 4.3), the opengles 3.0 is introduced here....
            // see http://developer.android.com/guide/topics/graphics/opengl.html
            if(androidVersonCode >= 18 || version.major <= 2) {
                NGLOG_INFO("trying to create GLES context: %s.%s", version.major, version.minor);
                tfw::GLFormat fmt(8, 8, 8, 0, 24, 0, 0, true);
                bool contextCreated = false;

                EGLGraphicsContext context;
                context.setFormat(fmt);
                context.setContextVersion(version.major, version.minor);
                context.setVerboseLogging(false);
                contextCreated = context.initPBufferSurface(1, 1);

                if (contextCreated) {
                    NGLOG_INFO("reported GLES version: %s.%s", context.versionMajor(), context.versionMinor());
                    NGLOG_INFO("collecting GLES info for context: %s.%s", version.major, version.minor);
                    queryCommon(gles);
                    for (size_t j = i; j < GLES_VERSION_COUNT; ++j) {
                        GLES_VERSIONS[j].query(gles);
                    }
                    hasGles = true;
                }
                context.destroy();
            } else {
                NGLOG_INFO("Skipping GLES version(%s.%s) for Android Version Code %s", version.major, version.minor, androidVersonCode);    
            }
        }
        epoxy_gl_reinitialize_function_pointers();
    }
#else
    void collectGles(SystemInfo& sysinf, GLESInfo& gles, bool& hasGles)
    {
        static const Version GLES_VERSIONS[] = {
            // iOS currently only has GLES 3.0 and the minor version cannot be passed to the context
            // creation api.
            { 3, 0, &queryGLES30 },
            { 2, 0, &queryGLES20 }
        };
        static const size_t GLES_VERSION_COUNT = sizeof(GLES_VERSIONS) / sizeof(GLES_VERSIONS[0]);
        for (size_t i = 0; i < GLES_VERSION_COUNT && !hasGles; ++i) {
            const Version& version = GLES_VERSIONS[i];
            tfw::GLFormat fmt(8, 8, 8, 0, 24, 0, 0, true);
            bool contextCreated = false;
            
            EAGLContext *context = nil;
            switch(version.major) {
                case 3:
                    context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];
                    break;
                case 2:
                    context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];
                    break;
                default:
                    NGLOG_ERROR("iOS: unsupported OpenGLES version: %s.%s", version.major, version.minor);
            }
            if (context != nil) {
                [EAGLContext setCurrentContext:context];
                contextCreated = true;
            }
            
            if (contextCreated) {
                NGLOG_INFO("collecting GLES info for context: %s.%s", version.major, version.minor);
                queryCommon(gles);
                for (size_t j = i; j < GLES_VERSION_COUNT; ++j) {
                    GLES_VERSIONS[j].query(gles);
                }
                hasGles = true;
            }
            
            [EAGLContext setCurrentContext:nil];
            [context release];
            context = nil;
        }
        epoxy_gl_reinitialize_function_pointers();
    }
#endif
}


void sysinf::collectGlInfo(SystemInfo &systemInfo)
{
    detail::collectGl(systemInfo.glInfo, systemInfo.hasGL);
#if defined(__ANDROID__) || TARGET_OS_IPHONE
    detail::collectEgl(systemInfo.eglInfo, systemInfo.hasEGL);
    detail::collectGles(systemInfo, systemInfo.glesInfo, systemInfo.hasGLES);
#endif
}
