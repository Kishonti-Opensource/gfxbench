# This module defines two macros intended to be used in the in-house FindXXX modules:
#
# 	find_any_standard_lib(<name> <path> [<subdirname>] [<libname>])
#   find_any_standard_lib_coda(<name>)
#
# The macros help finding any library which is deployed by the NaviGenie standards.
# See the description of the standard at the end of this description
#
# ---------------------------------------------------
#
# The first macro finds any library that is deployed by the NaviGenie standards
#
# 	find_any_standard_lib(<name> <path> [<subdirname>] [<libname>])
# 
# where
# - <name> is the name of the library, same as the first argument of the find_package command
# - <path> is the path of the directory containing the directory of the library,
#          e.g. "something/libraries". Then the macro will look in the "something/libraries/<name>" folder
# - <subdirname> is an optional argument, used when the directory of the library is not the same as <name>
# - <libname> is an optional argument, used when the library file name is not the same as <name>
#
# If the requested library can be found, these variables will be set:
#     <uppercased-name>_INCLUDE_DIRS
#     <uppercased-name>_LIBRARIES
#	  <uppercased-name>_FOUND (will be set to 1)
#     <uppercased-name>_FOUND_STATIC if OPT_USE_STATIC_LIBS is ON and there
#                                    are a static lib available (marked with
#                                    "_a" postifx and the static one is found.
#                                    It's not ON in every case a static lib is
#                                    found.
#
# otherwise these vars will be unset
#
# ------------------------------------------------------
#
# The second macros calls the find_package_handle_standard_args macro
#
#   find_any_standard_lib_coda(<name>)
#
# where
#
# - <name> is the name of the library, same as the first argument of the find_package command
#
# -------------------------------------------
# Complete example:
# 
# The find module FindCoolLib.cmake can be implemented like this:
#
# include(FindAnyStandardLib)
# find_any_standard_lib(coollib ${CMAKE_CURRENT_LIST_DIR/../libraries)
# # any other libs which coollib is dependent on, can be found here and its paths added to coollib's paths
# find_any_standard_lib_coda(coollib)
#
# ---------------------------------------------
#
# NaviGenie standard library deployment
#
# The directory structure of the library must be as follows (example uses zlib)
# The <build-tag> is a string generated by the BuildTag module and describes
# platform/compiler/runtimelib parameters of the build
#
# zlib/include/1_2_5 - the ZLIB_INCLUDE_DIRS path for version 1.2.5
# zlib/include/1_2_6 - the ZLIB_INCLUDE_DIRS path for for version 1.2.6
# zlib/lib/<build-tag>-1_2_5/zlib.lib - the ZLIB_LIBRARIES path for each build-tag
# zlib/lib/<build-tag>-1_2_6/zlib.lib - the ZLIB_LIBRARIES path for each build-tag
# zlib/zlib.dummy - empty file that helps the find_path (must match the findXXX name)
#
# In case of non-versioned deployment
#
# coollib/include - the COOLLIB_INCLUDE_DIRS
# coollib/lib/<build-tag>/mylib.lib - COOLLIB_LIBRARIES path
# coollib/coollib.dummy - empty file that helps the find_path
#
# Shared and static libraries
#
# When a library has both shared and static builds, on Windows,
# where both kinds of libs are named *.lib, the static version
# must be postfixed with _a (zlib_a.lib)
# This is used when the OPT_PREFER_STATIC_LIBS is on
# No need to mark the libs if there's only static version
#
# Debug libraries
#
# Debug libraries can be either in the lib specified by the debug
# build-tag (usually an added -gd according to the boost convention)
# but can also be in the same directory as the release lib
# with an added d postfix (d, _d, or, when marking static libs
# _a_d, _ad, _da, _d_a, d_a).
# Debug libraries can be omitted entirely.

# ---------------------------------------------------
FUNCTION(fasl_get_name_candidates fasl_gnc_name fasl_gnc_name_list_out)
#if input name (fasl_gnc_name) begins with "lib", add another one without lib
#if input name doesn't begins with "lib", add another one with lib
#example input: "curl" -> output: "curl;libcurl"
#example input: "libcurl" -> output: "libcurl;curl"
set(fasl_gnc_name_list ${fasl_gnc_name})
string(REGEX MATCH "^(lib|Lib|LIB)" r ${fasl_gnc_name})
if (r)
	string(SUBSTRING ${fasl_gnc_name} 3 -1 nolib)
	list(APPEND fasl_gnc_name_list ${nolib})
else()
	list(APPEND fasl_gnc_name_list "lib${fasl_gnc_name}")
endif()
set(${fasl_gnc_name_list_out} ${fasl_gnc_name_list} PARENT_SCOPE)
ENDFUNCTION()

# input: list, output: same list, each element postfixed with string
MACRO(postfix_list pwa_list pwa_postfix pwa_list_out)
	unset(${pwa_list_out})
	foreach(i IN LISTS ${pwa_list})
		list(APPEND ${pwa_list_out} "${i}${pwa_postfix}")
	endforeach()
ENDMACRO()

MACRO(find_any_standard_lib fasl_name fasl_path)

	#message("argv ${ARGV}, argc ${ARGC}")
	string(TOUPPER ${fasl_name} fasl_upper_name)
	
	#handle optional arguments
	if(${ARGC} GREATER 2)
		set(fasl_subdir ${ARGV2})
	else()
		unset(fasl_subdir)
	endif()
	
	if(${ARGC} GREATER 3)
		set(fasl_libname ${ARGV3})
	else()
		unset(fasl_libname)
	endif()

	#message("fasl_subdir ${fasl_subdir}")
	#message("fasl_libname ${fasl_libname}")
	
	#TODO: we should not depend on platform here
	#      and libraries directory is only a temporary fix
	if (WIN32)
		if (fasl_subdir)
			set(fasl_findpath ${fasl_path}/libraries/${fasl_subdir})
		else()
			set(fasl_findpath ${fasl_path}/libraries/${fasl_name})
		endif()
	else()
	endif()
	#message("fasl_findpath ${fasl_findpath}")
	
	if (NOT fasl_libname)
		set(fasl_libname ${fasl_name})
	endif()
	
	#find library root with the help of the XXX.dummy file
	find_path(${fasl_name}_DIR ${fasl_name}.dummy PATHS ${fasl_findpath} CMAKE_FIND_ROOT_PATH_BOTH)
	
	if (NOT ${fasl_name}_DIR)
		message(AUTHOR_WARNING "FindAnyStandardLib: couldn't find file \"${fasl_name}.dummy\" in path \"${fasl_findpath}\"")
	endif()

	if(${fasl_name}_DIR)
		#assemble the components of path to the actual lib files
		set(fasl_base_path ${${fasl_name}_DIR})
		
		include(BuildTag)
		build_tag(fasl_bt fasl_btd)
		
		
		include(FindBestVersionDir)
		find_best_version_dir(${fasl_name} ${fasl_base_path}/lib ${fasl_bt} fasl_good_version)
		
		#message("find_best_version_dir(${fasl_name} ${fasl_base_path}/lib ${fasl_bt} -> ${fasl_good_version})")
		
		if(fasl_good_version)
			# assemble libpaths for versioned libraries
			set(fasl_libpath "${fasl_base_path}/lib/${fasl_bt}-${fasl_good_version}")
			set(fasl_libdpath "${fasl_base_path}/lib/${fasl_btd}-${fasl_good_version}")
		else()
			# no good version found, possible reason: this library is non-versioned
			# assemble libpaths for non-versioned libraries but only if there's no version request
			if (NOT ${fasl_name}_FIND_VERSION )
				set(fasl_libpath "${fasl_base_path}/lib/${fasl_bt}")
				set(fasl_libdpath "${fasl_base_path}/lib/${fasl_btd}")
			else()
				message(WARNING "FindAnyStandardLib: VERSION ${fasl_name}_FIND_VERSION requested but no matching version found.")
				unset(fasl_libpath)
				unset(fasl_libdpath)
			endif()
		endif()
		
		if ( fasl_libpath AND fasl_libdpath )
			unset(FASL_LIB CACHE)
			unset(FASL_LIBD CACHE)
			fasl_get_name_candidates(${fasl_libname} fasl_name_list)
			if (OPT_PREFER_STATIC_LIBS)
				postfix_list(fasl_name_list _a fasl_name_list_a)
				find_library(FASL_LIB NAMES ${fasl_name_list_a} PATHS ${fasl_libpath} CMAKE_FIND_ROOT_PATH_BOTH)
				if (FASL_LIB)
					find_library(FASL_LIBD NAMES ${fasl_name_list_a} PATHS ${fasl_libdpath} CMAKE_FIND_ROOT_PATH_BOTH)
					# if not found, try many combinations of 'a' and 'd'
					foreach(i IN ITEMS _a_d _ad _da _d_a d_a)
						if (NOT FASL_LIBD)
							postfix_list(fasl_name_list ${i} fasl_name_list_i)
							find_library(FASL_LIBD NAMES ${fasl_name_list_i} PATHS ${fasl_libpath} CMAKE_FIND_ROOT_PATH_BOTH)
						endif()
					endforeach()
				endif()
			endif()
			if (FASL_LIB)
				# found static
				set(${fasl_upper_name}_FOUND_STATIC 1)
			else()
				# static not found or not even tried, find the regular name
				find_library(FASL_LIB NAMES ${fasl_name_list} PATHS ${fasl_libpath} CMAKE_FIND_ROOT_PATH_BOTH)
				if (FASL_LIB)
					find_library(FASL_LIBD NAMES ${fasl_name_list} PATHS ${fasl_libdpath} CMAKE_FIND_ROOT_PATH_BOTH)
					# if not found, try possible postfixes
					foreach(i IN ITEMS _d d)
						if (NOT FASL_LIBD)
							postfix_list(fasl_name_list ${i} fasl_name_list_i)
							#message("postfix_list ${fasl_name_list} ${i} -> ${fasl_name_list_i}")
							find_library(FASL_LIBD NAMES ${fasl_name_list_i} PATHS ${fasl_libpath} CMAKE_FIND_ROOT_PATH_BOTH)
							#message("find_library NAMES ${fasl_name_list_i} PATHS ${fasl_libpath} CMAKE_FIND_ROOT_PATH_BOTH -> ${FASL_LIBD}")
						endif()
					endforeach()
				endif()
			endif()
			if (NOT FASL_LIB)
				message(AUTHOR_WARNING "FindAnyStandardLib: No library found in ${fasl_libpath} (names: ${fasl_name_list})")
			endif()
		endif()
			
		if (FASL_LIB)
			# everything's fine, assemble final result paths
			if (fasl_good_version)
				set(${fasl_upper_name}_INCLUDE_DIRS ${${fasl_name}_DIR}/include/${fasl_good_version})
			else()
				set(${fasl_upper_name}_INCLUDE_DIRS ${${fasl_name}_DIR}/include)
			endif()
			if (FASL_LIBD)
				set(${fasl_upper_name}_LIBRARIES optimized ${FASL_LIB} debug ${FASL_LIBD})
			else()
				set(${fasl_upper_name}_LIBRARIES general ${FASL_LIB})
				message("${fasl_name}: No debug library found, using optimized for both builds.")
			endif()
			
			set(${fasl_upper_name}_FOUND 1)
		else()
			# unset paths to indicate failure
			unset(${fasl_upper_name}_INCLUDE_DIRS)
			unset(${fasl_upper_name}_LIBRARIES)
			unset(${fasl_upper_name}_FOUND)
		endif()
		# remove temporary variables from cache
		unset(FASL_LIB CACHE)
		unset(FASL_LIBD CACHE)
	endif()
ENDMACRO()

MACRO(find_any_standard_lib_coda faslc_name)
	string(TOUPPER ${faslc_name} fasl_upper_name)
	include(FindPackageHandleStandardArgs)
	find_package_handle_standard_args(${faslc_name} DEFAULT_MSG ${fasl_upper_name}_LIBRARIES ${fasl_upper_name}_INCLUDE_DIRS)
ENDMACRO()
