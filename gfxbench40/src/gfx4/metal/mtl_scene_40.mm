/*
 * Copyright (c) 2005-2025, Kishonti Ltd
 * SPDX-License-Identifier: BSD-3-Clause
 * This file is part of GFXBench. See the top-level LICENSE file for details.
 */
#include "mtl_scene_40.h"

#include <cmath>
#include <cstddef>
#include <map>

#include "ng/log.h"
#include "ng/stringutil.h"

#include "kcl_light2.h"
#include "kcl_planarmap.h"
#include "kcl_room.h"
#include "kcl_actor.h"
#include "kcl_animation4.h"
#include "kcl_io.h"

#include "platform.h"
#include "misc2.h"
#include "../global_test_environment.h"

#include "glb_kcl_adapter.h"
#include "mtl_scene_40_support.h"
#include "mtl_mesh4.h"
#include "mtl_material4.h"
#include "mtl_occlusion_cull.h"
#include "mtl_cascaded_shadow_map.h"
#include "mtl_compute_hdr40.h"
#include "mtl_gbuffer.h"
#include "mtl_stride_blur.h"
#include "mtl_compute_motion_blur.h"
#include "mtl_lensflare.h"
#include "metal/mtl_fragment_blur.h"
#include "metal/mtl_pipeline_builder.h"
#include "mtl_dynamic_data_buffer.h"
#include "mtl_particlesystem4.h"

#include "fbo.h"
#include "fbo_metal.h"

#include "graphics/graphicscontext.h"
#include "../gfxbench/gfxbench.h"

#include "property.h"
#include "gui_interface.h"

#include "dummy_gui.h"
#ifdef HAVE_GUI_FOLDER
#include "gfxgui.h"
#endif

#define ProfilerBeginPass(x)
#define ProfilerEndPass()

using namespace KCL;
using namespace MetalRender;

KRL_Scene* MetalRender::CreateMTLScene40(const GlobalTestEnvironment* const gte)
{
	return new MTL_Scene_40(gte);
}

MTL_Scene_40::MTL_Scene_40(const GlobalTestEnvironment* const gte)
{
	MTLPipeLineBuilder::SetScene(KCL::SV_40, this);

	m_gte = gte;
	m_adaptation_mode = m_gte->GetTestDescriptor()->m_adaptation_mode;

	m_gbuffer = NULL;

	cubemaps_inited = false;

	// occlusion cull for non tessellated geometry
	// indirect draw commands calculated by occlusion cull compute shader
#if TARGET_OS_EMBEDDED
	m_occlusion_cull_indirect_enabled = false;
#else
	m_occlusion_cull_indirect_enabled = true;
#endif
	
	// occlusion cull for tessellated geometry
	//   macOS: indirect draw command generated by tessellation kernel
	//   iOS: the pathes are dropped with zero tessellation factor
	m_occlusion_cull_tessellated_enabled = true;
#if !TARGET_OS_EMBEDDED
	MTLPipeLineBuilder::AddGlobalDefine("HAS_INDIRECT_PATCH", 1);
#endif
	
	if (m_occlusion_cull_tessellated_enabled)
	{
		MTLPipeLineBuilder::AddGlobalDefine("OCCLUSION_CULL_TESSELLATED", 1);
	}

	m_cull_non_instanced_meshes_enabled = false;
	m_render_occluders_enabled = false;
	m_compute_bright_pass_enabled = false;
	m_framebuffer_gamma_correction = true;
	m_is_compute_warmup = false;
	m_portrait_mode = false;

	m_sunColorStrength = 1.0f;
	m_fogColorStrength = 1.0f;
	m_last_animation_time = -1;

	m_dynamic_cubemaps[0] = NULL;
	m_dynamic_cubemaps[1] = NULL;
	m_paraboloid_culling = NULL;

	m_occlusion_cull = NULL;

	m_compute_hdr = NULL;
	m_dof_blur = NULL;
	m_ao_shadow_blur = NULL;
	m_compute_motion_blur = NULL;
	m_cascaded_shadow_map = NULL;
	m_shadow_material = NULL;
	m_transparent_shadow_material = NULL;
	m_transparent_billboard_shadow_material = NULL;
	m_tessellated_shadow_material = NULL;
	m_lensflare = NULL;

	m_carActor_hero = NULL;
	m_carActor_evil = NULL;

	m_emitter_rate_anim[0] = NULL;
	m_emitter_rate_anim[1] = NULL;

	m_camera_cut_track = NULL;
	m_prev_camera_clip = -1;
	m_camera_clip_changed = false;
	m_prev_mvp_valid = false;

	m_topdown_shadow = NULL;

	for (KCL::uint32 i = 0; i < NUM_STATIC_ENVMAPS; ++i)
		m_static_cubemaps[i] = NULL;

	for( int i = 0; i< NUM_OF_EMITTERS; i++)
	{
		m_emitters[i] = 0;
	}

	m_warmup_helper = NULL;

	m_tessellation_viewport_scale = 0.0f;

	ComputeEmitter::ResetParticleSystemSeed();
}


MTL_Scene_40::~MTL_Scene_40()
{
	delete m_gbuffer;

	for (int i = 0; i < 4; i++)
	{
		delete m_emitters[i] ;
		m_emitters[i] = 0 ;
	}

	for (KCL::uint32 i = 0; i < NUM_STATIC_ENVMAPS; ++i)
	{
		delete m_static_cubemaps[i];
		m_static_cubemaps[i] = NULL;
	}
    
    releaseObj(m_cubemap_sampler);

	//delete m_topdown_shadow; //note: deleted by scene_handler
	releaseObj(m_topdown_shadow_sampler);
    
    delete m_tessellator;

	delete m_fboEnvMap;
	delete m_dynamic_cubemaps[0];
	delete m_dynamic_cubemaps[1];
	delete m_paraboloid_culling;

	delete m_occlusion_cull;
	delete m_compute_hdr;
	delete m_dof_blur;
	delete m_ao_shadow_blur;
	delete m_compute_motion_blur;
	delete m_cascaded_shadow_map;
	delete m_lensflare;

	delete m_emitter_rate_anim[0];
	delete m_emitter_rate_anim[1];

	delete m_camera_cut_track;

	delete m_warmup_helper;

	MTLPipeLineBuilder::SetScene(KCL::SV_INVALID, nullptr);
	MetalRender::Pipeline::ClearCashes();
}

void MTL_Scene_40::SimulateParticles(id<MTLCommandBuffer> command_buffer)
{
    if (m_is_compute_warmup)
    {
        return;
    }
    
    bool need_to_emit = false;
    bool need_to_simulate = false;
    
    for( int i=0; i < NUM_OF_EMITTERS; i++)
    {
        KCL::_key_node *emitter_anim_track = m_emitter_rate_anim[i/2];
        
        KCL::Node* node = NULL;
        if ( m_carActor_hero)
        {
            if ( i == 0)
            {
                node = KCL::Node::SearchNode( m_carActor_hero->m_root, "model_car_hero_wmove_BL_loc");
            }
            else if ( i == 1)
            {
                node = KCL::Node::SearchNode( m_carActor_hero->m_root, "model_car_hero_wmove_BR_loc");
            }
        }
        
        if ( m_carActor_evil)
        {
            if ( i == 2)
            {
                node = KCL::Node::SearchNode( m_carActor_evil->m_root, "model_car_evil_wmove_BL_loc");
            }
            else if ( i == 3)
            {
                node = KCL::Node::SearchNode( m_carActor_evil->m_root, "model_car_evil_wmove_BR_loc");
            }
        }
        
        if ( node && emitter_anim_track)
        {
            KCL::Vector4D r;
            float time = m_animation_time * m_animation_multiplier / 1000.0f;
            float time_base = 0.0f;
            
            KCL::_key_node::Get( r, emitter_anim_track, time, time_base);
            
            m_emitters[i]->AdjustToDisplace4(node->m_world_pom, r.x);
            
            float delta_time = m_frame_consts.time_dt_pad2.y;
            delta_time = (delta_time < 0) ? 0 : delta_time;
            m_emitters[i]->Animate(delta_time, m_animation_time);
            
            need_to_emit |= m_emitters[i]->NeedToEmit();
            need_to_simulate |= m_emitters[i]->NeedToSimulate();
        }
    }
    
    if (need_to_emit)
    {
        for (int i = 0; i < NUM_OF_EMITTERS; i++)
        {
            m_emitters[i]->Emit(command_buffer);
        }
    }
    
    if (need_to_simulate)
    {
        for (int i = 0; i < NUM_OF_EMITTERS; i++)
        {
            m_emitters[i]->Simulate(command_buffer);
        }
    }
    
    
    //
    //  save particle buffers
    //
    const std::vector<int> &frames = m_gte->GetTestDescriptor()->m_particle_buffer_save_frames;
    if (frames.size())
    {
        bool save_buffers = std::find(frames.begin(), frames.end(), m_animation_time) != frames.end();
        
        if (save_buffers)
        {
            for (int i = 0; i < NUM_OF_EMITTERS; i++)
            {
				m_emitters[i]->SynchronizeParticleBuffer(m_command_queue);
                m_emitters[i]->SaveState(m_animation_time);
            }
        }
    }
}

void MTL_Scene_40::RenderParticles(id<MTLCommandBuffer> command_buffer)
{
    MetalRender::Texture *tt[2] =
    {
        static_cast<MetalRender::Texture*>(m_smokeMaterial->m_textures[2]),
        static_cast<MetalRender::Texture*>(m_topdown_shadow)
    };
    
    KCL::Vector3D eye_forward(-m_active_camera->GetView().v13, -m_active_camera->GetView().v23, -m_active_camera->GetView().v33);

    id <MTLRenderCommandEncoder> encoder = [command_buffer renderCommandEncoderWithDescriptor:m_particles_pass_desc];
    encoder.label = @"Render Particles";

    [encoder setDepthStencilState:m_billboard_point_depth_stencil];
    
    tt[0]->Set(encoder, 0);
    tt[1]->Set(encoder, 7);

    for( int i=0; i < NUM_OF_EMITTERS; i++)
    {
        m_emitters[i]->Render(encoder, m_billboard_point_pipline, m_active_camera->GetViewProjection(), m_active_camera->GetView(), m_active_camera->GetEye(), tt, m_topdown_shadow_sampler, eye_forward);
    }
    [encoder endEncoding];
}

KCL::KCL_Status MTL_Scene_40::InitEmitters()
{
    int single_frame = m_gte->GetTestDescriptor()->m_single_frame;
    bool single_frame_mode = single_frame != -1;
    
    for (int i = 0; i < NUM_OF_EMITTERS; i++)
    {
        m_emitters[i] = new MetalRender::ComputeEmitter(256, single_frame_mode, m_device);
        m_emitters[i]->Init(m_warmup_helper, m_dynamic_buffer_pool);
        std::string name = "emitter";
        name.push_back('0' + i);
        m_emitters[i]->SetName( name );
        m_emitters[i]->SetParticleLifetime( 1.1f);
        m_emitters[i]->SetGravity( -2.0f);
        m_emitters[i]->SetFocusDistance( 0.01f);
    }
    
    {
        KCL::AssetFile pos_track_file("animations/car_hero_dust_emitter_rate_track");
        if (!pos_track_file.GetLastError())
        {
            _key_node::Read( m_emitter_rate_anim[0], pos_track_file);
            pos_track_file.Close();
        }
        else
        {
            INFO("ERROR: Can not load car_hero_dust_emitter_rate_track!");
            return KCL::KCL_TESTERROR_FILE_NOT_FOUND;
        }
    }
    
    {
        KCL::AssetFile pos_track_file("animations/car_evil_dust_emitter_rate_track");
        if (!pos_track_file.GetLastError())
        {
            _key_node::Read( m_emitter_rate_anim[1], pos_track_file);
            pos_track_file.Close();
        }
        else
        {
            INFO("ERROR: Can not load car_evil_dust_emitter_rate_track!");
            return KCL::KCL_TESTERROR_FILE_NOT_FOUND;
        }
    }
    
    //
    //  load particle buffers if exists
    //
    if (single_frame_mode)
    {
        for (int i = 0; i < NUM_OF_EMITTERS; i++)
        {
            m_emitters[i]->LoadState(single_frame);
        }
    }
    
    return KCL::KCL_TESTERROR_NOERROR;
}

KCL::KCL_Status MTL_Scene_40::Process_GL(GLB::FBO_COLORMODE color_mode, GLB::FBO_DEPTHMODE depth_mode, int samples)
{
#if !TARGET_OS_IPHONE
	m_force_highp = true;
#endif
	
	KCL::KCL_Status result = KCL::KCL_TESTERROR_NOERROR;

	m_context = (MetalGraphicsContext*)m_gte->GetGraphicsContext();

	// Find a usable Metal device
	m_device = m_context->getDevice();

	if (m_device == nil)
	{
		INFO("ERROR: Cannot init Metal device");
		return KCL::KCL_TESTERROR_UNKNOWNERROR;
	}
	
	{
		bool tessellation_supported = false;
#if TARGET_OS_IPHONE
		tessellation_supported |= [m_device supportsFeatureSet:MTLFeatureSet_iOS_GPUFamily3_v2];
#elif TARGET_OS_OSX
		tessellation_supported |= [m_device supportsFeatureSet:MTLFeatureSet_OSX_GPUFamily1_v2];
#endif
		if (!tessellation_supported) return KCL::KCL_TESTERROR_SHADER_ERROR;
	}

	m_dynamic_buffer_pool = new MetalRender::DynamicDataBufferPool(MetalRender::METAL_MAX_FRAME_LAG);

	m_dynamic_data_buffer = m_dynamic_buffer_pool->GetNewBuffer(2048 * 1024);


	// Clear the second material argument. Car Chases uses it for override the material
	if (m_rooms.size())
	{
		for (size_t i = 0; i < m_rooms[0]->m_meshes.size(); i++)
		{
			KCL::Mesh *m = m_rooms[0]->m_meshes[i];
			m->m_materials[RENDER_MATERIAL_ID] = NULL;
		}
	}

	for (size_t i = 0; i < m_actors.size(); i++)
	{
		for (size_t j = 0; j < m_actors[i]->m_meshes.size(); j++)
		{
			KCL::Mesh *m = m_actors[i]->m_meshes[j];
			m->m_materials[RENDER_MATERIAL_ID] = NULL;
		}
	}

	KCL::AssetFile track_file("animations/cc_track");
	if (!track_file.GetLastError())
	{
		_key_node::Read( m_camera_cut_track, track_file);
		track_file.Close();
	}
	else
	{
		INFO("ERROR: Can not load cc_track!");
		return KCL::KCL_TESTERROR_FILE_NOT_FOUND;
	}

	PropertyLoader prr;
	std::string path = "car_chase/scene_4.prop";
	std::vector<SerializeEntry> entries = prr.DeSerialize(m_frame_consts, path);
	for (auto entry = entries.begin(); entry != entries.end(); ++entry)
	{
		if (entry->m_key == "fogColorStrength")
		{
			m_fogColorStrength = ng::atof(entry->m_value.c_str());
			break;
		}
		if (entry->m_key == "SunColorStrength")
		{
			m_sunColorStrength = ng::atof(entry->m_value.c_str());
			break;
		}
	}

	m_light_color.x = m_frame_consts.global_light_color.x;
	m_light_color.y = m_frame_consts.global_light_color.y;
	m_light_color.z = m_frame_consts.global_light_color.z;

	m_fogColor.x = m_frame_consts.fogCol.x;
	m_fogColor.y = m_frame_consts.fogCol.y;
	m_fogColor.z = m_frame_consts.fogCol.z;

	// Screen-space scale factor for adaptive tesselation
	m_tessellation_viewport_scale = sqrtf(float(m_viewport_width) / 1920.0f * float(m_viewport_height) / 1080.0f);

	INFO("We have %d occluder(s)", m_occluders.size());
	if (m_occluders.empty())
	{
		INFO("!!! Warning !!! The scene does not contain any occluder meshes !!! !!! !!!");
		//assert(false);
	}

	//find car actors
	for(int i=0; i<m_actors.size(); ++i)
	{
		if (m_actors[i]->m_name.find("car_evil") != std::string::npos)
		{
			m_carActor_evil = m_actors[i];
		}
		else if (m_actors[i]->m_name.find("car_hero") != std::string::npos)
		{
			m_carActor_hero = m_actors[i];
		}
	}

	// Global light direction comes from scene.xml so be sure it's normalized
	m_light_dir.normalize();

	MetalRender::Pipeline::InitShaders(m_scene_version);

	MTLPipeLineBuilder::AddGlobalDefine("MAX_INSTANCES", MAX_INSTANCES);
	MTLPipeLineBuilder::AddGlobalDefine("VELOCITY_BUFFER_RGBA8", GFXB4::GBuffer::VELOCITY_BUFFER_RGBA8 ? 1 : 0);
	MTLPipeLineBuilder::AddGlobalDefine("NORMAL_BUFFER_RGBA8", GFXB4::GBuffer::NORMAL_BUFFER_RGBA8 ? 1 : 0);

#if ENABLE_CUBEMAP_FP_RENDER_TARGETS
	MTLPipeLineBuilder::AddGlobalDefine("CUBEMAP_FP_RENDERTARGET_ENABLED", 1);
#endif

#if ENABLE_LIGHTCOMBINE_FP_RENDER_TARGET
	MTLPipeLineBuilder::AddGlobalDefine("LIGHTCOMBINE_FP_RENDERTARGET_ENABLED", 1);
#endif

#if DEBUG_SHADOW
	MTLPipeLineBuilder::AddGlobalDefine("DEBUG_SHADOW", 1);
#endif

#if HAVE_GUI_FOLDER
	//MTLPipeLineBuilder::AddGlobalDefine("EDITOR_MODE", 0);
#endif

	result = InitEmitters();
	if (result != KCL::KCL_TESTERROR_NOERROR)
	{
		return result;
	}
    
    // Create Tessellator
    m_tessellator = new MetalRender::Tessellator;
    m_tessellator->Init(m_device, 16, m_dynamic_buffer_pool);
    
	// Create the custom materials
	m_sky_lightcombine_pass = dynamic_cast<Material4*>(CreateMaterial("gfxb4_sky_mat_light_combine"));
	m_sky_mat_paraboloid = CreateMaterial("gfxb4_sky_paraboloid_mat");
	m_sky_mat_paraboloid->m_material_type = KCL::Material::SKY;

	// Shadow caster materials (solid and transparent)
	m_shadow_material = dynamic_cast<Material4*>(CreateMaterial("shadow_caster_solid_mat"));
	m_transparent_shadow_material = dynamic_cast<Material4*>(CreateMaterial("shadow_caster_transparent_mat"));
	m_transparent_billboard_shadow_material = dynamic_cast<Material4*>(CreateMaterial("shadow_caster_transparent_billboard_mat"));
	m_tessellated_shadow_material = dynamic_cast<Material4*>(CreateMaterial("shadow_caster_tessellated_mat"));

	// Create the dynamic envmaps
	const KCL::uint32 envmap_size = m_viewport_width / 2;

	m_fboEnvMap = new FboEnvMap(m_device, envmap_size);

#if ENABLE_CUBEMAP_FP_RENDER_TARGETS
	m_dynamic_cubemaps[0] = m_fboEnvMap->CreateParaboloidEnvMapWithFormat(MTLPixelFormatRGBA16Float); //allow mipmapping
	m_dynamic_cubemaps[1] = m_fboEnvMap->CreateParaboloidEnvMapWithFormat(MTLPixelFormatRGBA16Float);
#else
	m_dynamic_cubemaps[0] = m_fboEnvMap->CreateParaboloidEnvMapWithFormat(MTLPixelFormatRGBA8Unorm); //allow mipmapping
	m_dynamic_cubemaps[1] = m_fboEnvMap->CreateParaboloidEnvMapWithFormat(MTLPixelFormatRGBA8Unorm); //allow mipmapping
#endif
	m_paraboloid_culling = new ParaboloidCulling(envmap_size, envmap_size, 128.0f);

	// Init G-buffers
	m_gbuffer = new GFXB4::GBuffer();
	m_gbuffer->Init(m_viewport_width, m_viewport_height);
    
	m_quad_buffer = new MetalRender::QuadBuffer(QuadBuffer::kBlitQuadLandscape);

	InitPostProcessPipeline();

	IncrementProgressTo(0.5f);

	IncrementProgressTo(0.59f);
	for( uint32 i=0; i<m_rooms.size(); i++)
	{
		XRoom *room = m_rooms[i];
		for( uint32 j=0; j<room->m_meshes.size(); j++)
		{
			room->m_meshes[j]->DeleteUnusedAttribs();
		}
	}

	result = KCL::g_os->LoadingCallback(0);
	if (result != KCL::KCL_TESTERROR_NOERROR)
	{
		return result;
	}

	IncrementProgressTo(0.6f);

	for (uint32 i = 0; i < m_sky_mesh.size(); i++)
	{
		m_sky_mesh[i]->DeleteUnusedAttribs();
	}

	for(size_t i = 0; i < m_meshes.size(); ++i)
	{
		GFXB4::Mesh3 * mesh = dynamic_cast<GFXB4::Mesh3*>(m_meshes[i]);
		mesh->InitVertexAttribs();

#ifndef HAVE_GUI_FOLDER
		mesh->DeleteVertexAttribs();
#endif
	}

	result = KCL::g_os->LoadingCallback(0);
	if (result != KCL::KCL_TESTERROR_NOERROR)
	{
		return result;
	}

	IncrementProgressTo(0.7f);
	INFO("Loading shaders...");
	result = reloadShaders();
	if (result != KCL::KCL_TESTERROR_NOERROR)
	{
		return result;
	}

	result = KCL::g_os->LoadingCallback(0);
	if (result != KCL::KCL_TESTERROR_NOERROR)
	{
		return result;
	}

	for(size_t i = 0; i < m_materials.size(); ++i)
	{
		m_materials[i]->InitImages();
		if (result != KCL::KCL_TESTERROR_NOERROR)
		{
			return result;
		}

		result = KCL::g_os->LoadingCallback(0);
		if (result != KCL::KCL_TESTERROR_NOERROR)
		{
			return result;
		}
	}

	//topdown shadow sampler
	for (size_t i = 0; i < m_textures.size(); ++i)
	{
		if (m_textures[i]->getName().find("topdown_ao_depth") != std::string::npos)
		{
			m_topdown_shadow = m_textures[i];

			// Set up the sampler
			MTLSamplerDescriptor * sampler_desc = [[MTLSamplerDescriptor alloc] init];

			sampler_desc.sAddressMode = MTLSamplerAddressModeRepeat;
			sampler_desc.tAddressMode = MTLSamplerAddressModeRepeat;
			sampler_desc.minFilter = MTLSamplerMinMagFilterLinear;
			sampler_desc.magFilter = MTLSamplerMinMagFilterLinear;
			sampler_desc.mipFilter = MTLSamplerMipFilterNotMipmapped;

			m_topdown_shadow_sampler = [m_device newSamplerStateWithDescriptor:sampler_desc];
			releaseObj(sampler_desc);
			break;
		}
	}

	if (!m_topdown_shadow)
	{
		INFO("Error! Can not load topdown_ao_depth");
		return KCL::KCL_TESTERROR_FILE_NOT_FOUND;
	}

	IncrementProgressTo(0.9f);


	INFO("Loading cube maps...");
	std::string filename = EnvmapsDirectory() + "envmap";
#if !TARGET_OS_EMBEDDED
	m_static_cubemaps[0] = TextureFactory().CreateAndSetup(KCL::Texture_CubeArray, filename.c_str(), KCL::TC_Clamp);
#else
	for (KCL::uint32 i = 0; i < NUM_STATIC_ENVMAPS; ++i)
	{
		char name[1024];
		sprintf(name, "%s%03d", filename.c_str(), i);
		m_static_cubemaps[i] = TextureFactory().CreateAndSetup(KCL::Texture_Cube, name, KCL::TC_Clamp);
	}
#endif
	if (m_static_cubemaps[0])
	{
		// Set up the sampler
		MTLSamplerDescriptor * sampler_desc = [[MTLSamplerDescriptor alloc] init];

		sampler_desc.sAddressMode = MTLSamplerAddressModeClampToEdge;
		sampler_desc.tAddressMode = MTLSamplerAddressModeClampToEdge;
		sampler_desc.rAddressMode = MTLSamplerAddressModeClampToEdge;
		sampler_desc.minFilter = MTLSamplerMinMagFilterLinear;
		sampler_desc.magFilter = MTLSamplerMinMagFilterLinear;
		sampler_desc.mipFilter = MTLSamplerMipFilterLinear;

		m_cubemap_sampler = [m_device newSamplerStateWithDescriptor:sampler_desc];
		releaseObj(sampler_desc);
	}
	else
	{
		INFO("Error! Can not load static cube maps: %s", filename.c_str());
	}

	m_prev_camera_clip = -1;

#ifdef HAVE_GUI_FOLDER
	m_gui = std::unique_ptr<GFXGui>(new GFXGui(*this));
#else
	m_gui = std::unique_ptr<DummyGUI>(new DummyGUI());
#endif

	m_gui->Init();

	m_command_queue = m_context->getMainCommandQueue();

	CreateRenderPassDescriptors();

	// Execute warm up process
	NGLOG_INFO("Warm up compute shaders...");
	double warmup_start = KCL::g_os->GetTimeMilliSec();
	m_warmup_helper = new WarmUpHelper(m_device, this, m_gte->GetTestDescriptor()->m_workgroup_sizes);
	WarmUpShaders();
	NGLOG_INFO("warm up time: %s", int(KCL::g_os->GetTimeMilliSec() - warmup_start));

	m_last_animation_time = -1;

	return KCL::KCL_TESTERROR_NOERROR;
}


void MTL_Scene_40::Resize(KCL::uint32 w, KCL::uint32 h)
{
	if (w > h)
	{
		m_portrait_mode = false;
		MTL_Scene_Base::Resize(w,h);
	}
	else
	{
		m_portrait_mode = true;
		MTL_Scene_Base::Resize(h,w);
	}
}


void MTL_Scene_40::InitPostProcessPipeline()
{
	m_hdr_output = GFXB4::CreateRenderTarget(m_device, m_viewport_width, m_viewport_height, MTLPixelFormatRGBA8Unorm);
	m_dof_output = GFXB4::CreateRenderTarget(m_device, m_viewport_width, m_viewport_height, MTLPixelFormatRGBA8Unorm);
	m_mb_output = GFXB4::CreateRenderTarget(m_device, m_viewport_width, m_viewport_height, MTLPixelFormatRGBA8Unorm);
	m_ssao_output = GFXB4::CreateRenderTarget(m_device, m_viewport_width/2, m_viewport_height/2, MTLPixelFormatR8Unorm);
	m_ssds_output = GFXB4::CreateRenderTarget(m_device, m_viewport_width, m_viewport_height, MTLPixelFormatRGBA8Unorm);

#if ENABLE_LIGHTCOMBINE_FP_RENDER_TARGET
	m_lightcombine_output = GFXB4::CreateRenderTarget(m_device, m_viewport_width, m_viewport_height, MTLPixelFormatRGBA16Float);
#else
	m_lightcombine_output = GFXB4::CreateRenderTarget(m_device, m_viewport_width, m_viewport_height, MTLPixelFormatRGBA8Unorm);
#endif
	m_motion_blur_output = GFXB4::CreateRenderTarget(m_device, m_viewport_width, m_viewport_height, MTLPixelFormatRGBA8Unorm);

	LoadHDR();
}

void MTL_Scene_40::LoadHDR()
{
	KCL::KCL_Status error = KCL::KCL_TESTERROR_NOERROR;

	// depth of field blur strength for full HD
	int dof_blur_strength = 7;
	
	// on iPhone the rendertarget is in portrait mode
	KCL::uint32 m_dim = KCL::Min(m_viewport_height,m_viewport_width);
	dof_blur_strength = (dof_blur_strength*m_dim) / 1080; // normalize for actual resolution

	delete m_dof_blur;
	m_dof_blur = new FragmentBlur(m_device);
	m_dof_blur->Init(m_viewport_width, m_viewport_height, dof_blur_strength, MTLPixelFormatRGBA8Unorm, 1);

	MTLPipeLineBuilder sb;

	if (m_framebuffer_gamma_correction)
	{
		sb.AddDefine("USE_SHADER_GAMMA_CORRECTION");
	}

	m_hdr_pipeline =
	sb.ShaderFile("pp_hdr.shader")
	.SetVertexLayout(QuadBuffer::GetVertexLayout())
	.Build(error);

	if (GFXB4::GBuffer::HIZ_DEPTH_ENABLED)
	{
		sb.AddDefine("USE_HIZ_DEPTH");
		sb.AddDefineInt("MAX_MIP_LEVEL", m_gbuffer->GetHiZDepthLevels() - 1);
	}

	m_ssao_pipeline =
	sb.ShaderFile("pp_ssao.shader")
	.SetVertexLayout(QuadBuffer::GetVertexLayout())
	.SetTypeByPixelFormat(MTLPixelFormatR8Unorm)
	.Build(error);

	m_dof_pipeline =
	sb.ShaderFile("pp_dof.shader")
	.SetVertexLayout(QuadBuffer::GetVertexLayout())
	.SetTypeByPixelFormat(MTLPixelFormatBGRA8Unorm)
	.AddDefineInt("ROTATE_DOF", m_portrait_mode?1:0)
	.Build(error);

	m_ssds_pipeline =
	sb.ShaderFile("pp_ssds.shader")
	.SetVertexLayout(QuadBuffer::GetVertexLayout())
	.Build(error);

	m_lightcombine_pipeline =
	sb.ShaderFile("light_combine.shader")
	.HasDepth(true)
	.SetVertexLayout(QuadBuffer::GetVertexLayout())
	.Build(error);

	const KCL::uint32 shadow_size = KCL::Max(m_viewport_height,m_viewport_width) / 2;
	delete m_cascaded_shadow_map;
	m_cascaded_shadow_map = new CascadedShadowMap(m_device, shadow_size);
	m_cascaded_shadow_map->Init(m_viewport_width, m_viewport_height, GetShadowMapFormat());

	// Load luminance and bright pass
	delete m_compute_hdr;
	m_compute_hdr = new ComputeHDR40(m_device);
	m_compute_hdr->Init(m_viewport_width,m_viewport_height, MTLPixelFormatRGBA8Unorm, m_compute_bright_pass_enabled, this);

	delete m_lensflare ;
	m_lensflare = new Lensflare(m_device);
	m_lensflare->Init(m_viewport_width,m_viewport_height, m_portrait_mode);

	int ao_shadow_blur_strength = 3;
	ao_shadow_blur_strength = (ao_shadow_blur_strength * KCL::Min(m_viewport_height,m_viewport_width)) / 1080; // normalize for actual resolution
	delete m_ao_shadow_blur;
	m_ao_shadow_blur = new StrideBlur();

	m_ao_shadow_blur->Init(m_device, m_viewport_width, m_viewport_height, 3, ao_shadow_blur_strength);

	WarmUpShaders();
}

void MTL_Scene_40::WarmUpShaders()
{
	m_is_compute_warmup = true;

	OcclusionCull *new_occlusion_cull = new OcclusionCull(m_device);
	new_occlusion_cull->Init(m_device, m_dynamic_buffer_pool, m_warmup_helper, this, m_viewport_width / 2, m_viewport_height / 2, MTLPixelFormatDepth32Float, m_quad_buffer, MAX_INSTANCES, m_cull_non_instanced_meshes_enabled, false);
	delete m_occlusion_cull;
	m_occlusion_cull = new_occlusion_cull;

	ComputeMotionBlur *new_mb = new ComputeMotionBlur(m_device, m_viewport_width, m_viewport_height, 8, ComputeMotionBlur::Adaptive);
	new_mb->Init(m_warmup_helper);
	delete m_compute_motion_blur;
	m_compute_motion_blur = new_mb;

	// warmup particle system with a specific emitter
	m_emitters[0]->Init(m_warmup_helper, m_dynamic_buffer_pool);

	// apply the warmup workgroup size for all emitter
	for (int i = 0; i < NUM_OF_EMITTERS; i++)
	{
		m_emitters[i]->Init(m_warmup_helper, m_dynamic_buffer_pool);
	}

    m_is_compute_warmup = false;
}

KCL::KCL_Status MTL_Scene_40::reloadShaders()
{
	KCL::KCL_Status error;

    MTLPipeLineBuilder sb;
	m_billboard_point_pipline =
    sb.ShaderFile("billboard_point.shader")
	.SetBlendType(MetalRender::Pipeline::BlendType::ALPHA_X_ONE_MINUS_SOURCE_ALPHA)
    .HasDepth(true)
    .Build(error);
    
    MTLDepthStencilDescriptor* depthStencilDesc = [[MTLDepthStencilDescriptor alloc] init];
    depthStencilDesc.depthWriteEnabled = NO;
    depthStencilDesc.depthCompareFunction = MTLCompareFunctionLess;
    
    m_billboard_point_depth_stencil = [m_device newDepthStencilStateWithDescriptor:depthStencilDesc];
    
    releaseObj(depthStencilDesc);

	// Load material shaders
	for (KCL::uint32 i = 0; i < m_materials.size(); i++)
	{
		error = ((Material4*)m_materials[i])->InitShaders(this);
		if (error != KCL::KCL_TESTERROR_NOERROR)
		{
			INFO("Can not init material: %s", m_materials[i]->m_name.c_str());
			return error;
		}
        
        	INFO("Init material: %s", m_materials[i]->m_name.c_str());

		error = KCL::g_os->LoadingCallback(0);
		if (error != KCL::KCL_TESTERROR_NOERROR)
		{
			return error;
		}
	}
	return KCL::KCL_TESTERROR_NOERROR;
}

void MTL_Scene_40::ReloadHDR()
{
	LoadHDR();
}

static unsigned g_instanceDataOffset;
static unsigned g_occlusionDataOffset;

void MTL_Scene_40::RenderCascadedShadow(__strong id<MTLCommandBuffer>& command_buffer)
{
    m_tessellator->m_depthPass = true;
	ProfilerBeginPass("Shadow");
	static std::vector<Mesh*> visible_meshes[3];
	static std::vector<KCL::MeshInstanceOwner2*> visible_mios;
	static std::vector<GFXB4::Mesh3::InstanceData> instance_data;
	static std::vector<KCL::Mesh*> instances;

	KCL::Camera2 *shadow_camera;

	m_cascaded_shadow_map->BuildFrustums(m_light_dir, m_active_camera);

	for (int i = 0; i < CASCADE_COUNT; i++)
	{
		visible_meshes[0].clear();
		visible_meshes[1].clear();
		visible_mios.clear();

		m_cascaded_shadow_map->FrustumCull(i, this, visible_meshes, visible_mios, m_force_cast_shadows);

		shadow_camera = m_cascaded_shadow_map->GetCamera(i);

		CollectRenderMaterials(visible_meshes[0], m_shadow_material, PassType::SHADOW, i);
		CollectRenderMaterials(visible_meshes[1], m_transparent_shadow_material, PassType::SHADOW, i);

		MTL_Scene4Tools::SortMeshes(visible_meshes[0], shadow_camera, false);
        
        BeginEncodeRender();
		EncodeRender(shadow_camera, visible_meshes[0], m_shadow_material , 0, 0, 0, PassType::SHADOW, false, i);
		EncodeRender(shadow_camera, visible_meshes[1], m_transparent_shadow_material, 0, 0, 0, PassType::SHADOW, false, i);
        
		instance_data.clear();
		instances.clear();

		CollectRenderMaterials(visible_mios, m_shadow_material, PassType::SHADOW, i);

		CollectInstances(CollectionFlags::CollectOpaque | CollectionFlags::CollectTransparent, instance_data, instances, visible_mios);

		g_instanceDataOffset = m_dynamic_data_buffer->WriteDataAndGetOffset(nil, instance_data.data(), sizeof(GFXB4::Mesh3::InstanceData) * instance_data.size());

		EncodeRender(shadow_camera, instances, m_shadow_material, 0, 0, 0, PassType::SHADOW, false, i);
		
		{
			OcclusionConstants oc;
			oc.vp = m_cascaded_shadow_map->GetCamera(i)->GetViewProjection();
			oc.view_port_size.x = m_cascaded_shadow_map->GetTextureMapSize();
			oc.view_port_size.y = m_cascaded_shadow_map->GetTextureMapSize();
			oc.near_far_ratio = -m_cascaded_shadow_map->GetCamera(i)->GetProjection().v33;
			g_occlusionDataOffset = m_dynamic_data_buffer->WriteDataAndGetOffset(nil, &oc, sizeof(oc));
		}

        EndEncodeRender(command_buffer, [this, i](id<MTLCommandBuffer> cmd){
            auto encoder = m_cascaded_shadow_map->GetRenderPassEncoder(cmd, i);
			[encoder setVertexBuffer:m_dynamic_data_buffer->GetCurrentBuffer() offset:g_occlusionDataOffset atIndex:OCCLUSION_UNIFORMS_SLOT];
			return encoder;
        }, false, true);

	}

	ProfilerEndPass();
    m_tessellator->m_depthPass = false;
}

void MTL_Scene_40::Render()
{
	@autoreleasepool
	{
		id <MTLCommandBuffer> command_buffer = [m_command_queue commandBuffer];
		command_buffer.label = @"Car Chase Frame";
		m_dynamic_buffer_pool->InitFrame();

		m_tessellator->EncodeIndirectBufferCopy(command_buffer);
		
		m_frame_consts_offset = m_dynamic_data_buffer->WriteDataAndGetOffset(nil, &m_frame_consts, sizeof(FrameConstants));

		RenderCascadedShadow(command_buffer);


		// Main camera occlusion cull
		ProfilerBeginPass("Generate HiZ");
		if (m_occlusion_cull_indirect_enabled || m_occlusion_cull_tessellated_enabled)
		{
			m_occlusion_cull->CreateHiZ(command_buffer, m_active_camera, m_occluders, m_quad_buffer);
		}
		ProfilerEndPass();

		// Execute the occlusion cull
		ProfilerBeginPass("OC");
		if (m_occlusion_cull_indirect_enabled)
		{
			m_occlusion_cull->ExecuteOcclusionCull(command_buffer, m_active_camera, m_visible_meshes[0], m_visible_instances);
		}
		ProfilerEndPass();
        
		bool hero_visible = false;
		bool evil_visible = false;

		for (int i = 0; i < m_visible_actors.size(); ++i)
		{
			if (m_visible_actors[i] == m_carActor_hero)
			{
				hero_visible = true;
			}
			else if (m_visible_actors[i] == m_carActor_evil)
			{
				evil_visible = true;
			}
		}

		KCL::Material* orig_sky_mat0 = NULL;
		KCL::Material* orig_sky_mat1 = NULL;
		if (m_sky_mesh.size())
		{
			orig_sky_mat0 = m_sky_mesh[0]->m_materials[0];
			orig_sky_mat1 = m_sky_mesh[0]->m_materials[1];
			for(int i=0; i<m_sky_mesh.size(); ++i)
			{
				m_sky_mesh[i]->SetMaterials(m_sky_mat_paraboloid, m_sky_mat_paraboloid);
			}
		}

		// Envmap #0
		if (m_carActor_hero && (hero_visible || !cubemaps_inited))
		{
			KCL::Vector3D pos( m_carActor_hero->m_root->m_world_pom.v[12], m_carActor_hero->m_root->m_world_pom.v[13] , m_carActor_hero->m_root->m_world_pom.v[14]);

			pos.y += 2.0f;

			UpdateEnvmap(command_buffer, pos, 0);
		}

		// Envmap #1
		if (m_carActor_evil && (evil_visible || !cubemaps_inited))
		{
			KCL::Vector3D pos( m_carActor_evil->m_root->m_world_pom.v[12], m_carActor_evil->m_root->m_world_pom.v[13] , m_carActor_evil->m_root->m_world_pom.v[14]);

			pos.y += 2.0f;

			UpdateEnvmap(command_buffer, pos, 1);
		}

		cubemaps_inited = true;

		for (int i = 0; i < m_sky_mesh.size(); ++i)
		{
			m_sky_mesh[i]->SetMaterials(orig_sky_mat0, orig_sky_mat1);
		}

		// Render not instanced, opaque meshes
        ProfilerBeginPass("Main");

		MTL_Scene4Tools::SortMeshes(m_visible_meshes[0], m_active_camera, false);
        
        BeginEncodeRender();
        
        EncodeRender(m_active_camera, m_visible_meshes[0], 0, 0, 0, 0, PassType::NORMAL, m_occlusion_cull_indirect_enabled && m_cull_non_instanced_meshes_enabled);
		ProfilerEndPass();

		if (m_render_occluders_enabled)
		{
            EncodeRender(m_active_camera, m_occluders, 0, 0, 0, 0, PassType::NORMAL, false);
		}

		if (m_visible_instances.size())
		{
			// Collect the instanced meshes
			std::vector<GFXB4::Mesh3::InstanceData> instance_data;
			std::vector<KCL::Mesh*> instances;

            CollectInstances(CollectionFlags::CollectOpaque, instance_data, instances, m_visible_instances);

            if (!m_occlusion_cull_indirect_enabled)
			{
				// Upload the mesh matrices
				g_instanceDataOffset = m_dynamic_data_buffer->WriteDataAndGetOffset(nil, instance_data.data(), sizeof(GFXB4::Mesh3::InstanceData) * instance_data.size());
			}


			// Render instanced meshes
			ProfilerBeginPass("MainInst");
			EncodeRender(m_active_camera, instances, 0, 0, 0, 0, PassType::NORMAL, m_occlusion_cull_indirect_enabled);
			ProfilerEndPass();
		}
        
		{
			OcclusionConstants oc;
			oc.vp = m_active_camera->GetViewProjection();
			oc.view_port_size = m_gbuffer->GetViewport();
			oc.near_far_ratio = -m_active_camera->GetProjection().v33;
			g_occlusionDataOffset = m_dynamic_data_buffer->WriteDataAndGetOffset(nil, &oc, sizeof(oc));
		}
		
        EndEncodeRender(command_buffer, [this](id<MTLCommandBuffer> cmd){
            auto encoder =  m_gbuffer->GetGBufferPassEncoder(cmd);
			[encoder setVertexBuffer:m_dynamic_data_buffer->GetCurrentBuffer() offset:g_occlusionDataOffset atIndex:OCCLUSION_UNIFORMS_SLOT];
            return encoder;
        }, m_occlusion_cull_indirect_enabled, true);

		m_gbuffer->DownsampleDepth(command_buffer, m_active_camera, m_quad_buffer);

		ExecuteSSAOPass(command_buffer);

		ExecuteSSDSPass(command_buffer);

		//Blur SSAO and shadow to full-size target in a single pass
		ProfilerBeginPass("AOShadowBlur");
		m_ao_shadow_blur->Render(command_buffer, m_quad_buffer, m_active_camera, m_ssds_output, m_gbuffer->GetDepthTexture());
		ProfilerEndPass();

		ExecuteLightCombineSkyPass(command_buffer);

		ExecuteTransparentPass(command_buffer);
        
        // Handle camera changes
        KCL::uint32 adaptation_mode = m_adaptation_mode;
        
        if (adaptation_mode == ComputeReduction40::ADAPTATION_ENABLED && (m_camera_clip_changed || m_frame_consts.time_dt_pad2.y <= 0.0f))
        {
            // Turn off the adaptation for the current frame
            adaptation_mode = ComputeReduction40::ADAPTATION_DISABLED;
        }
        
        // Set the luminance adaption mode
        m_compute_hdr->GetComputeReduction()->SetAdaptationMode(adaptation_mode);

        // Disable motion blur on camera changes
        const bool enable_motion_blur = m_prev_mvp_valid  && m_mblur_enabled;

        ProfilerBeginPass("SimulateParticles");
        SimulateParticles(command_buffer);
        ProfilerEndPass();
        
        UBOFrame uboframe;
        uboframe.time_dt_pad2 = m_frame_consts.time_dt_pad2;
        uboframe.ABCD = m_frame_consts.ABCD;
        uboframe.EFW_tau = m_frame_consts.EFW_tau;
        uboframe.exposure_bloomthreshold_pad2 = m_frame_consts.exposure_bloomthreshold_tone_map_white_pad;
        
        ProfilerBeginPass("ComputeHDR");
        m_compute_hdr->SetInputTexture(m_lightcombine_output);
        m_compute_hdr->Execute(command_buffer, uboframe);
        ProfilerEndPass();
        
		ExecuteToneMapBloomPass(command_buffer);
        
		ProfilerBeginPass("RenderParticles");
		RenderParticles(command_buffer);
		ProfilerEndPass();

		ExecuteMotionBlurPass(command_buffer, enable_motion_blur);

		ExecuteDOFPass(command_buffer, enable_motion_blur);

		//
		//  Lensflare
		//
		ProfilerBeginPass("Lensflare");
		m_lensflare->m_depth_texture = m_gbuffer->GetDepthTexture();
		m_lensflare->m_camera = m_active_camera;
		m_lensflare->Execute(command_buffer, m_dynamic_data_buffer);
		m_lensflare->Render(command_buffer, m_dynamic_data_buffer);
		ProfilerEndPass();

		KCL::uint32 slot = m_dynamic_buffer_pool->GetCurrentSlot();

#pragma mark Frame End callback
		[command_buffer addCompletedHandler:^(id <MTLCommandBuffer> completedCommandBuffer)
		 {
			 m_dynamic_buffer_pool->MarkSlotUnused(slot);
		 }];

		[command_buffer commit];
	} // @autoreleasepool
}


void MTL_Scene_40::CreateRenderPassDescriptors()
{
	m_ssao_pass_desc = [[MTLRenderPassDescriptor alloc] init];
	m_ssao_pass_desc.colorAttachments[0].texture = m_ssao_output;
	m_ssao_pass_desc.colorAttachments[0].clearColor = MTLClearColorMake(1.0f, 1.0f, 1.0f, 1.0f);
	m_ssao_pass_desc.colorAttachments[0].loadAction = MTLLoadActionClear;
	m_ssao_pass_desc.colorAttachments[0].storeAction = MTLStoreActionStore;

	m_lightcombine_pass_desc = [[MTLRenderPassDescriptor alloc] init];
	m_lightcombine_pass_desc.colorAttachments[0].texture = m_lightcombine_output;
	m_lightcombine_pass_desc.colorAttachments[0].loadAction = MTLLoadActionClear;
	m_lightcombine_pass_desc.colorAttachments[0].storeAction = MTLStoreActionStore;
	m_lightcombine_pass_desc.depthAttachment.texture = m_gbuffer->GetDepthTexture();
	m_lightcombine_pass_desc.depthAttachment.loadAction = MTLLoadActionLoad;
	m_lightcombine_pass_desc.depthAttachment.storeAction = MTLStoreActionDontCare;

	m_ssds_pass_desc = [[MTLRenderPassDescriptor alloc] init];
	m_ssds_pass_desc.colorAttachments[0].texture = m_ssds_output;
	m_ssds_pass_desc.colorAttachments[0].loadAction = MTLLoadActionDontCare;
	m_ssds_pass_desc.colorAttachments[0].storeAction = MTLStoreActionStore;

	m_tonemap_pass_desc = [[MTLRenderPassDescriptor alloc] init];
	m_tonemap_pass_desc.colorAttachments[0].texture = m_hdr_output;
	m_tonemap_pass_desc.colorAttachments[0].loadAction = MTLLoadActionDontCare;
	m_tonemap_pass_desc.colorAttachments[0].storeAction = MTLStoreActionStore;

	m_motion_blur_pass_desc = [[MTLRenderPassDescriptor alloc] init];
	m_motion_blur_pass_desc.colorAttachments[0].texture = m_motion_blur_output;
	m_motion_blur_pass_desc.colorAttachments[0].loadAction = MTLLoadActionDontCare;
	m_motion_blur_pass_desc.colorAttachments[0].storeAction = MTLStoreActionStore;

	m_particles_pass_desc = [[MTLRenderPassDescriptor alloc] init];
	m_particles_pass_desc.colorAttachments[0].texture = m_hdr_output;
	m_particles_pass_desc.colorAttachments[0].loadAction = MTLLoadActionLoad;
	m_particles_pass_desc.colorAttachments[0].storeAction = MTLStoreActionStore;
	m_particles_pass_desc.depthAttachment.texture = m_gbuffer->GetDepthTexture();
	m_particles_pass_desc.depthAttachment.storeAction = MTLStoreActionDontCare;
	m_particles_pass_desc.depthAttachment.loadAction = MTLLoadActionLoad;

	m_dof_pass_desc = [[MTLRenderPassDescriptor alloc] init];
	// Color target is on-screen; texture is assigned later
	m_dof_pass_desc.colorAttachments[0].loadAction = MTLLoadActionDontCare;
	m_dof_pass_desc.colorAttachments[0].storeAction = MTLStoreActionStore;
}



void MTL_Scene_40::ExecuteSSAOPass(id<MTLCommandBuffer> command_buffer)
{
	id <MTLRenderCommandEncoder> encoder = [command_buffer renderCommandEncoderWithDescriptor:m_ssao_pass_desc];
	encoder.label = @"SSAO";

	m_ssao_pipeline->Set(encoder);

	[encoder setFragmentTexture:m_gbuffer->GetDepthHiZTexture() atIndex:TEXTURE_UNIT0_SLOT];
	[encoder setFragmentTexture:m_gbuffer->GetNormalTexture() atIndex:TEXTURE_UNIT1_SLOT];

	SSAOConstants ssao_params;

	if (m_active_camera)
	{
		ssao_params.depth_parameters = m_active_camera->m_depth_linearize_factors;

		KCL::Vector3D v[4];

		m_active_camera->CalculateRaysToFullscreenBillboard(v, true);

		for (KCL::uint32 i = 0; i < 4; ++i)
			ssao_params.corners[i] = v[i].v;

		ssao_params.projection_scale = fabsf(-float(m_viewport_height) / (2.0f * tanf(KCL::Math::Rad(m_active_camera->GetFov() * 0.5f))));

	}

    m_dynamic_data_buffer->WriteAndSetData<false, true>(encoder, FILTER_CONSTANTS_SLOT, &ssao_params, sizeof(SSAOConstants));

	m_quad_buffer->Draw(encoder);
	[encoder endEncoding];
}

void MTL_Scene_40::ExecuteSSDSPass(id<MTLCommandBuffer> command_buffer)
{
	id <MTLRenderCommandEncoder> encoder = [command_buffer renderCommandEncoderWithDescriptor:m_ssds_pass_desc];
	encoder.label = @"SSDS";

	m_ssds_pipeline->Set(encoder);

	[encoder setFragmentTexture:m_ssao_output atIndex:TEXTURE_UNIT1_SLOT];

	if (m_topdown_shadow)
	{
		[encoder setFragmentTexture:static_cast<MetalRender::Texture *>(m_topdown_shadow)->GetTexture() atIndex:TEXTURE_UNIT7_SLOT];
		[encoder setFragmentSamplerState:m_topdown_shadow_sampler atIndex:TEXTURE_UNIT7_SLOT];
	}

	[encoder setFragmentTexture:m_gbuffer->GetDepthTexture() atIndex:DEPTH_UNIT0_SLOT];
	[encoder setFragmentTexture:m_cascaded_shadow_map->GetTexture() atIndex:CASCADED_SHADOW_TEXTURE_ARRAY_SLOT];
	[encoder setFragmentSamplerState:m_cascaded_shadow_map->GetSampler() atIndex:CASCADED_SHADOW_TEXTURE_ARRAY_SLOT];

	SSDSConstants ssds_params;

	if (m_active_camera)
	{
		ssds_params.depth_parameters = m_active_camera->m_depth_linearize_factors;

		KCL::Vector3D v[4];

		m_active_camera->CalculateRaysToFullscreenBillboard(v);

		for (KCL::uint32 i = 0; i < 4; ++i)
			ssds_params.corners[i] = v[i].v;

		ssds_params.view_pos = m_active_camera->GetEye();

		ssds_params.cascaded_frustum_distances = m_cascaded_shadow_map->GetFrustumDistances();

		for (KCL::uint32 i = 0; i < CASCADE_COUNT; ++i)
		{
			ssds_params.cascaded_shadow_matrices[i] = m_cascaded_shadow_map->GetShadowMatrices()[i];
		}
	}

    m_dynamic_data_buffer->WriteAndSetData<false, true>(encoder, FILTER_CONSTANTS_SLOT, &ssds_params, sizeof(ssds_params));

	m_quad_buffer->Draw(encoder);
	[encoder endEncoding];
}


void MTL_Scene_40::ExecuteLightCombineSkyPass(id<MTLCommandBuffer> command_buffer)
{
	id <MTLRenderCommandEncoder> encoder = [command_buffer renderCommandEncoderWithDescriptor:m_lightcombine_pass_desc];
	encoder.label = @"Light Combine and Sky";

	[encoder setFrontFacingWinding:MTLWindingCounterClockwise];

	m_lightcombine_pipeline->Set(encoder);

	[encoder setFragmentTexture:m_gbuffer->GetAlbedoTexture() atIndex:TEXTURE_UNIT0_SLOT];
	[encoder setFragmentTexture:m_gbuffer->GetNormalTexture() atIndex:TEXTURE_UNIT1_SLOT];
	[encoder setFragmentTexture:m_gbuffer->GetParamsTexture() atIndex:TEXTURE_UNIT2_SLOT];
	[encoder setFragmentTexture:m_ao_shadow_blur->m_color_texture atIndex:TEXTURE_UNIT4_SLOT];

	if (m_topdown_shadow)
    {
		[encoder setFragmentTexture:static_cast<MetalRender::Texture *>(m_topdown_shadow)->GetTexture() atIndex:TEXTURE_UNIT7_SLOT];
        [encoder setFragmentSamplerState:m_topdown_shadow_sampler atIndex:TEXTURE_UNIT7_SLOT];
    }

	for (KCL::uint32 i = 0; i < NUM_STATIC_ENVMAPS; ++i)
    {
		[encoder setFragmentTexture:static_cast<MetalRender::Texture *>(m_static_cubemaps[i])->GetTexture() atIndex:STATIC_ENVMAPS_SLOT_0 + i];
    }
    
    [encoder setFragmentSamplerState:m_cubemap_sampler atIndex:STATIC_ENVMAPS_SLOT_0];

	[encoder setFragmentTexture:m_gbuffer->GetDepthTexture() atIndex:DEPTH_UNIT0_SLOT];

	[encoder setFragmentTexture:m_dynamic_cubemaps[0]->GetTexture() atIndex:ENVMAP1_DP_SLOT];
	[encoder setFragmentTexture:m_dynamic_cubemaps[1]->GetTexture() atIndex:ENVMAP2_DP_SLOT];

	FilterConstants filter_params;

	if (m_active_camera)
	{
		filter_params.depth_parameters = m_active_camera->m_depth_linearize_factors;
		filter_params.inv_view = m_frag_consts.inv_view;
		filter_params.view_pos = m_frag_consts.view_pos;

		KCL::Vector3D v[4];

		m_active_camera->CalculateRaysToFullscreenBillboard(v);

		for (KCL::uint32 i = 0; i < 4; ++i)
			filter_params.corners[i] = v[i].v;

		filter_params.dpcam_view = m_dpcam.GetView();
	}

	[encoder setFragmentBuffer:m_dynamic_data_buffer->GetCurrentBuffer() offset:GetFrameConstsOffset() atIndex:FRAME_CONSTANTS_SLOT];
    
    m_dynamic_data_buffer->WriteAndSetData<false, true>(encoder, FILTER_CONSTANTS_SLOT, &filter_params, sizeof(filter_params));

	m_quad_buffer->Draw(encoder);


	// Now render the sky
	CollectRenderMaterials(m_sky_mesh, m_sky_lightcombine_pass, PassType::REFLECTION);

	BeginEncodeRender();
	EncodeRender(m_active_camera, m_sky_mesh, m_sky_lightcombine_pass, 0, 0, 0, PassType::REFLECTION, false); //pass type == 1, so it will render simple color

	EndEncodeRender(command_buffer, [this, encoder](id<MTLCommandBuffer> cmd)
	{
		return encoder;
	}, false, false);
}


void MTL_Scene_40::ExecuteTransparentPass(id<MTLCommandBuffer> command_buffer)
{
	ProfilerBeginPass("Transparent");

	BeginEncodeRender();

	EncodeRender(m_active_camera, m_visible_meshes[1], 0, 0, 0, 0, PassType::NORMAL, m_occlusion_cull_indirect_enabled && m_cull_non_instanced_meshes_enabled); //HACK HACK HACK - needs a separate pass & shader to render into light combine

	EndEncodeRender(command_buffer, [this, command_buffer](id<MTLCommandBuffer> cmd)
	{
		auto encoder = m_gbuffer->GetTransparentAccumulationPassEncoder(command_buffer);

		return encoder;
	}, m_occlusion_cull_indirect_enabled && m_cull_non_instanced_meshes_enabled, false);
}


void MTL_Scene_40::ExecuteToneMapBloomPass(id<MTLCommandBuffer> command_buffer)
{
	id <MTLRenderCommandEncoder> encoder = [command_buffer renderCommandEncoderWithDescriptor:m_tonemap_pass_desc];
	encoder.label = @"Tone Mapping and Bloom";

	m_hdr_pipeline->Set(encoder);

	ProfilerBeginPass("ToneMap+Bloom");

	[encoder setFragmentTexture:m_lightcombine_output atIndex:TEXTURE_UNIT0_SLOT];
	[encoder setFragmentTexture:m_compute_hdr->GetBloomTexture() atIndex:TEXTURE_UNIT2_SLOT];
	[encoder setFragmentSamplerState:m_compute_hdr->GetBloomSampler() atIndex:TEXTURE_UNIT2_SLOT];

#if !ENABLE_LIGHTCOMBINE_FP_RENDER_TARGET
	[encoder setFragmentTexture:m_gbuffer->GetTransparentAccumTexture()  atIndex:TEXTURE_UNIT3_SLOT];
#endif

	[encoder setFragmentBuffer:m_compute_hdr->GetLuminanceBuffer() offset:0 atIndex:1];

	HDRConsts light_params;

	light_params.ABCD = m_frame_consts.ABCD;
	light_params.EFW_tau = m_frame_consts.EFW_tau;
	light_params.exposure_bloomthreshold_minmax_lum = m_frame_consts.exposure_bloomthreshold_tone_map_white_pad;

    m_dynamic_data_buffer->WriteAndSetData<false, true>(encoder, 0, &light_params, sizeof(light_params));

	m_quad_buffer->Draw(encoder);
	[encoder endEncoding];
}


void MTL_Scene_40::ExecuteMotionBlurPass(id<MTLCommandBuffer> command_buffer, bool enable_motion_blur)
{
	if (enable_motion_blur)
	{
		ProfilerBeginPass("mb-comp");
		m_compute_motion_blur->Execute(command_buffer, m_gbuffer->GetVelocityTexture());
		ProfilerEndPass();

		//combine lighting here
		ProfilerBeginPass("mb-blur");

		id <MTLRenderCommandEncoder> encoder = [command_buffer renderCommandEncoderWithDescriptor:m_motion_blur_pass_desc];
		encoder.label = @"Motion Blur Render";

		m_compute_motion_blur->GetBlurShader()->Set(encoder);

		ProfilerBeginPass("Motion Blur");

		[encoder setFragmentTexture:m_hdr_output atIndex:TEXTURE_UNIT0_SLOT];
		[encoder setFragmentTexture:m_gbuffer->GetVelocityTexture() atIndex:TEXTURE_UNIT4_SLOT];
		[encoder setFragmentTexture:m_compute_motion_blur->GetNeighborMaxTexture() atIndex:TEXTURE_UNIT6_SLOT];
		[encoder setFragmentTexture:m_gbuffer->GetDepthTexture() atIndex:DEPTH_UNIT0_SLOT];

		MotionBlurConstants mb_params;
		mb_params.mb_velocity_min_max_sfactor_pad = m_frame_consts.mb_velocity_min_max_sfactor_pad;
		mb_params.depth_parameters = m_active_camera->m_depth_linearize_factors;

        m_dynamic_data_buffer->WriteAndSetData<false, true>(encoder, 0, &mb_params, sizeof(MotionBlurConstants));

        [encoder setFragmentBuffer:m_compute_motion_blur->GetTapOffsetsBuffer() offset:0 atIndex:1];

		m_quad_buffer->Draw(encoder);
		[encoder endEncoding];
		
		ProfilerEndPass();
	}
}


void MTL_Scene_40::ExecuteDOFPass(id<MTLCommandBuffer> command_buffer, bool enable_motion_blur)
{
	if (m_depth_of_field_enabled)
	{
		id<MTLTexture> dof_input_texture;

		if (enable_motion_blur)
		{
			dof_input_texture = m_motion_blur_output;
		}
		else
		{
			dof_input_texture = m_hdr_output;
		}

		ProfilerBeginPass("DOF-blur");
		m_dof_blur->SetInputTexture(dof_input_texture);
		m_dof_blur->Execute(command_buffer);
		ProfilerEndPass();

		m_dof_pass_desc.colorAttachments[0].texture = dynamic_cast<GLB::FBOMetalBase*>(GLB::FBO::GetLastBind())->GetTexture();

		id <MTLRenderCommandEncoder> encoder = [command_buffer renderCommandEncoderWithDescriptor:m_dof_pass_desc];
		encoder.label = @"Depth of Field";

		m_dof_pipeline->Set(encoder);

		FilterConstants filter_params;

		filter_params.camera_focus = m_camera_focus_distance;
		filter_params.camera_focus_inv = 1.0 / m_camera_focus_distance;
		filter_params.dof_strength = m_active_camera->GetFov();
		filter_params.dof_strength_inv = 1.0 / m_active_camera->GetFov();
		filter_params.depth_parameters = m_active_camera->m_depth_linearize_factors;

		[encoder setFragmentTexture:dof_input_texture atIndex:TEXTURE_UNIT0_SLOT];
		[encoder setFragmentTexture:m_dof_blur->GetOutputTexture() atIndex:TEXTURE_UNIT1_SLOT];
		[encoder setFragmentTexture:m_gbuffer->GetDepthTexture() atIndex:DEPTH_UNIT0_SLOT];
        
        m_dynamic_data_buffer->WriteAndSetData<false, true>(encoder, FILTER_CONSTANTS_SLOT, &filter_params, sizeof(filter_params));

		m_quad_buffer->Draw(encoder);
		[encoder endEncoding];
	}
}


void MTL_Scene_40::UpdateGUI(KCL::uint32 cursorX, KCL::uint32 cursorY, bool mouseLPressed, bool mouseLClicked, bool mouseRPressed, bool mouseRClicked, const bool *downKeys)
{
	m_gui->UpdateGUI(cursorX, cursorY, mouseLPressed, mouseLClicked, mouseRPressed, mouseRClicked, downKeys);
}

static const Vector3D refs[6] =
{
	Vector3D(1, 0, 0),
	Vector3D(-1, 0, 0),
	Vector3D(0, 1, 0),
	Vector3D(0, -1, 0),
	Vector3D(0, 0, 1),
	Vector3D(0, 0, -1)
};
static const Vector3D ups[6] =
{
	Vector3D(0, -1, 0),
	Vector3D(0, -1, 0),
	Vector3D(0, 0, 1),
	Vector3D(0, 0, -1),
	Vector3D(0, -1, 0),
	Vector3D(0, -1, 0)
};

static const Vector3D refsParab[2] =
{
	Vector3D(0, 1, 0),
	Vector3D(0, 1, 0)
	//  Vector3D(0, 0, 1),
	//  Vector3D(0, 0, 1)
};
static const Vector3D upsParab[2] =
{
	Vector3D(0, 0, 1),
	Vector3D(0, 0, 1)
	//  Vector3D(0, 1, 0),
	//  Vector3D(0, 1, 0)
};

extern float multi;

void MTL_Scene_40::UpdateEnvmap(id<MTLCommandBuffer> command_buffer, const GLB::Vector3D &pos, KCL::uint32 idx)
{
	std::vector<Mesh*> visible_meshes[2];
	std::vector<KCL::PlanarMap*> visible_planar_maps;
	std::vector<KCL::Mesh*> meshes_to_blur;
	std::vector< std::vector<KCL::Mesh*> > visible_instances;


	for (KCL::uint32 i = 0; i < 2; ++i)
	{
		Vector2D nearfar;

		m_dpcam.Ortho(-1000.0, 1000.0, -1000.0, 1000.0, 0.01f, 1000.0f);
		m_dpcam.LookAt( pos, pos+refsParab[i], upsParab[i]);
		m_dpcam.Update();

		visible_meshes[0].clear();
		visible_meshes[1].clear();

		std::vector<Actor*> exclude_list;
		exclude_list.push_back(m_carActor_hero);
		exclude_list.push_back(m_carActor_evil);

		m_paraboloid_culling->m_force_cast = m_force_cast_reflections;
		FrustumCull(&m_dpcam, visible_planar_maps, visible_meshes, visible_instances, meshes_to_blur, m_pvs, nearfar, 0, true, true, &exclude_list, m_paraboloid_culling);

		m_dpcam.Ortho(-1000.0, 1000.0, -1000.0, 1000.0, nearfar.x, nearfar.y);
		m_dpcam.LookAt( pos, pos+refsParab[i], upsParab[i]);
		m_dpcam.Update();

		MTL_Scene4Tools::SortMeshes(visible_meshes[0], &m_dpcam, false);

		BeginEncodeRender();

		EncodeRender(&m_dpcam, visible_meshes[0], 0, 0, 0, 0, PassType::REFLECTION, false, i+1);

		std::vector<GFXB4::Mesh3::InstanceData> instance_data;
		std::vector<KCL::Mesh*> instances;

		CollectInstances(CollectionFlags::CollectOpaque, instance_data, instances, visible_instances);
        
        g_instanceDataOffset = m_dynamic_data_buffer->WriteDataAndGetOffset(nil, instance_data.data(), instance_data.size() * sizeof(GFXB4::Mesh3::InstanceData));

		EncodeRender(&m_dpcam, instances, 0, 0, 0, 0, PassType::REFLECTION, false, i+1);

		EndEncodeRender(command_buffer, [this, i, idx, instance_data](id<MTLCommandBuffer> cmd)
		{
			auto encoder = m_fboEnvMap->AttachParaboloid(cmd, m_dynamic_cubemaps[idx], i);

			encoder.label = [NSString stringWithFormat:@"Environment Map %u:%u", idx, i];

			return encoder;
		}, false, false);
	}

	id <MTLBlitCommandEncoder> blit_encoder = [command_buffer blitCommandEncoder];
	blit_encoder.label = [NSString stringWithFormat:@"Generate Environment Map %u Mipmaps", idx];

	[blit_encoder generateMipmapsForTexture:m_dynamic_cubemaps[idx]->GetTexture()];
	[blit_encoder endEncoding];
}


static std::vector<RenderInfo> g_renderList;


void MTL_Scene_40::BeginEncodeRender()
{
    g_renderList.clear();
}

void MTL_Scene_40::EncodeRender(KCL::Camera2* camera,
                             std::vector<Mesh*> &visible_meshes,
                             KCL::Material *_override_material,
                             KCL::PlanarMap * pm,
                             KCL::uint32 lod,
                             KCL::Light* light,
                             PassType::Enum pass_type,
                             bool occlusion_cull,
                             KCL::uint32 slice_id)
{
    
    if (visible_meshes.empty())
	{
        return;
	}

    RenderInfo renderInfo;
    renderInfo.useConstantOne = pass_type == PassType::SHADOW;
    renderInfo.occlusionCull = occlusion_cull;

    Material4 *override_material = dynamic_cast<Material4*>(_override_material);
    Material4 *prev_material = NULL;
    int prev_shader_variant = -1;
    KCL::uint32 texture_num_from_material = 0;
    
    KCL::Texture* ovrds[KCL::Material::MAX_IMAGE_TYPE] = {};
    
    if (pass_type == PassType::REFLECTION)
    {
        ovrds[KCL::Material::AUX2] = m_topdown_shadow;
    }
    else
    {
        //clear all overrides
        ovrds[KCL::Material::AUX2] = 0;
    }
    Material4::SetTextureOverrides(ovrds);
    
    // Calculate FOV scale for adaptive tessellation
    float tessellation_fov_scale;
    float aperture = (float)tanf( KCL::Math::Rad( camera->GetFov() / 2.0f)) * camera->GetNear();
    float left0 = -aperture * camera->GetAspectRatio();
    float right0 = aperture * camera->GetAspectRatio();
    float top0 = aperture;
    float bottom0 = -aperture;
    
    float w = right0 - left0;
    float h = top0 - bottom0;
    
    //values for 60 deg FOV (freecam) with 0.1m near plane dist
    float fov60_w = 0.205280095f;
    float fov60_h = 0.115470052f;
    
    tessellation_fov_scale = sqrtf(fov60_w / w  *  fov60_h / h);
    
    g_renderList.reserve(visible_meshes.size());
    
    // Loop through all meshes and draw each
    for (KCL::uint32 j = 0; j < visible_meshes.size(); ++j)
    {
        Mesh* sm = (Mesh*)visible_meshes[j];
        GFXB4::Mesh3 *glb_mesh  = (GFXB4::Mesh3 *)sm->m_mesh;
        
        if (!glb_mesh)
        {
            continue;
        }

		bool is_instanced_draw = sm->m_mio2 != NULL;
        
        // Use LOD for reflection pass
        KCL::Mesh3* selected_mesh = sm->m_mesh;
        if ((pass_type == PassType::REFLECTION) && (sm->m_mesh_variants[1]))
        {
            selected_mesh = sm->m_mesh_variants[1];
        }
        
        Material4 *material = (Material4*)sm->m_materials[RENDER_MATERIAL_ID];
        if (!material)
        {
            material = (Material4*)sm->m_material;
        }
        
        ShaderVariant::Enum shader_variant = selected_mesh->m_vertex_matrix_indices.size() ? ShaderVariant::SKELETAL : ShaderVariant::NORMAL;
        
        if (is_instanced_draw)
        {
            shader_variant = ShaderVariant::INSTANCED;
        }

        KCL::Matrix4x4 mvp;
        KCL::Matrix4x4 mv;
        KCL::Matrix4x4 model;
        KCL::Matrix4x4 inv_model;
        KCL::Matrix4x4 inv_modelview;
        Vector3D pos( sm->m_world_pom.v[12], sm->m_world_pom.v[13], sm->m_world_pom.v[14]);

        if (shader_variant == ShaderVariant::NORMAL)
        {
            if (material->m_material_type == KCL::Material::SKY)
            {
                mvp = sm->m_world_pom * camera->GetViewProjectionOrigo();
                mv = sm->m_world_pom * camera->GetView();
                mv.v[12] = 0.0f;
                mv.v[13] = 0.0f;
                mv.v[14] = 0.0f;
            }
            else
            {
                mvp = sm->m_world_pom * camera->GetViewProjection();
                mv = sm->m_world_pom * camera->GetView();
            }
            
            GLB::Matrix4x4::InvertModelView(mv, inv_modelview);
            
            model = sm->m_world_pom;
            inv_model = Matrix4x4::Invert4x3( sm->m_world_pom);
        }
        
        // Update constants
        {
            m_vert_consts.mvp = mvp;
            m_vert_consts.mv = mv;
            m_vert_consts.vp = camera->GetViewProjection();
            m_vert_consts.prev_vp = m_prev_vp;
            m_vert_consts.view = camera->GetView();
            m_vert_consts.model = model;
            m_vert_consts.inv_model = inv_model;
            
            
            KCL::Matrix4x4 inv_view;
            KCL::Matrix4x4 v = camera->GetView();
            KCL::Matrix4x4::InvertModelView(v, inv_view);
            m_frag_consts.inv_view = inv_view;
            m_frag_consts.view_pos = camera->GetEye();
        }
        
        if (!m_actors.empty())
        {
            float carIdx;
            
            if (sm->m_owner == m_carActor_evil)
            {
                carIdx = 254;
                
                //HACK FOR CAR PAINT MATERIAL
                if (sm->m_material->m_is_car_paint)
                {
                    carIdx = 255;
                }
            }
            else if (sm->m_owner == m_carActor_hero)
            {
                carIdx = 252;
                
                //HACK FOR CAR PAINT MATERIAL
                if (sm->m_material->m_is_car_paint)
                {
                    carIdx = 253;
                }
            }
            else if (sm->m_material->m_translucent_lighting_strength > 0.0f) //50..100, HACK: assume billboard is a branch with leafs, use two sided lighting to fake scattering
            {
                assert(sm->m_envmap_id < 50);
                carIdx = 50 + sm->m_envmap_id;
            }
            else //under 50
            {
                assert(sm->m_envmap_id < 50);
                carIdx = sm->m_envmap_id;
            }
            
            float translucent_factor = 0.0;
            if (sm->m_material->m_is_billboard && (sm->m_material->m_translucent_lighting_strength > 0.0))
            {
                translucent_factor = sm->m_material->m_translucent_lighting_strength * 0.5f; //lower half of range (0..0.5) for billboards
            }
            else if (sm->m_material->m_translucent_lighting_strength > 0.0)
            {
                translucent_factor = sm->m_material->m_translucent_lighting_strength * 0.5f + 0.5f; //upper half for non-billboards
            }
            
            m_frag_consts.carindex_translucency_ssaostr_fovscale = KCL::Vector4D(carIdx / 255.0, translucent_factor, 0.0, tessellation_fov_scale);
        }
        
        //car ao projection
        if (m_carActor_hero)
        {
            static const Matrix4x4 shadowM (0.5f, 0, 0, 0,
                                            0, 0.5f, 0, 0,
                                            0, 0, 0.5f, 0,
                                            0.5f, 0.5f, 0.5f, 1);
            
            KCL::Actor *car_actor = m_carActor_hero;
            
            KCL::Vector3D carPos = KCL::Vector3D(car_actor->m_root->m_world_pom.v[12], car_actor->m_root->m_world_pom.v[13], car_actor->m_root->m_world_pom.v[14]);
            KCL::Vector3D carUp = KCL::Vector3D(car_actor->m_root->m_world_pom.v[4], car_actor->m_root->m_world_pom.v[5], car_actor->m_root->m_world_pom.v[6]);
            KCL::Vector3D carFwd = KCL::Vector3D(car_actor->m_root->m_world_pom.v[8], car_actor->m_root->m_world_pom.v[9], car_actor->m_root->m_world_pom.v[10]);
            
            m_car_ao_cam.LookAt(carPos + carUp, carPos, carFwd);
            float sizeTweak = 2.6f;
            m_car_ao_cam.Ortho(-sizeTweak,sizeTweak,-sizeTweak,sizeTweak, -2, 2);
            m_car_ao_cam.Update();
            m_vert_consts.car_ao_matrix0 = m_car_ao_cam.GetViewProjection() * shadowM;
        }
        
        if (m_carActor_evil)
        {
            static const Matrix4x4 shadowM (0.5f, 0, 0, 0,
                                            0, 0.5f, 0, 0,
                                            0, 0, 0.5f, 0,
                                            0.5f, 0.5f, 0.5f, 1);
            
            KCL::Actor *car_actor = m_carActor_evil;
            
            KCL::Vector3D carPos = KCL::Vector3D(car_actor->m_root->m_world_pom.v[12], car_actor->m_root->m_world_pom.v[13], car_actor->m_root->m_world_pom.v[14]);
            KCL::Vector3D carUp = KCL::Vector3D(car_actor->m_root->m_world_pom.v[4], car_actor->m_root->m_world_pom.v[5], car_actor->m_root->m_world_pom.v[6]);
            KCL::Vector3D carFwd = KCL::Vector3D(car_actor->m_root->m_world_pom.v[8], car_actor->m_root->m_world_pom.v[9], car_actor->m_root->m_world_pom.v[10]);
            
            m_car_ao_cam.LookAt(carPos + carUp, carPos, carFwd);
            float sizeTweak = 2.6f;
            m_car_ao_cam.Ortho(-sizeTweak,sizeTweak,-sizeTweak,sizeTweak,-2,2);
            m_car_ao_cam.Update();

			m_vert_consts.car_ao_matrix1 = m_car_ao_cam.GetViewProjection() * shadowM;
        }
        
        if (m_tessellation_enabled)
        {
            if (m_active_camera)
            {
                for (int i = 0; i < 6; ++i)
                    m_tess_consts.frustum_planes[i] = m_active_camera->GetCullPlane(i);
            }
            
            if (Tessellator::ForceMaxTessFactorOne()) // [AAPL] Debug
            {
                m_tess_consts.tessellation_factor = KCL::Vector4D(1.0f, 1.0f, 1.0f, 100000.0f);
            }
            else
            {
                m_tess_consts.tessellation_factor = sm->m_material->m_tessellation_factor;
            }
            
            float tessellation_multiplier;
            // Precalculate the tessellation multiplier factor
            if (material->m_displacement_mode == KCL::Material::DISPLACEMENT_LOCAL)
            {
                // Local displacement
                tessellation_multiplier = 800.0f * m_tessellation_viewport_scale * tessellation_fov_scale;
            }
            else
            {
                // Bezier patch
                float tessellation_scale = m_tessellation_enabled ? sm->m_material->m_tessellation_factor.y : 1.0f;
                tessellation_multiplier = 1200.0f * (1.0f + tessellation_scale) * m_tessellation_viewport_scale * tessellation_fov_scale;
            }
            
            m_tess_consts.tessellation_multiplier = tessellation_multiplier;
        }
        else
        {
            m_tess_consts.tessellation_factor = KCL::Vector4D(1.0f, 1.0f, 1.0f, 100000.0f);
        }
        
        {
            int val = 1;
            if (slice_id == 1)
            {
                val = 1;
            }
            else if (slice_id == 2)
            {
                val = -1;
            }
            
            float tess_vp_scale = sqrtf(float(m_viewport_width) / 1920.0 * float(m_viewport_height) / 1080.0);
            
            m_vert_consts.cam_near_far_pid_vpscale = KCL::Vector4D(camera->GetNear(), camera->GetFar(), val, tess_vp_scale);
        }
        
        // mvp2: prev mvp for motion blur. For instanced meshes it comes from the instance buffer
        if (shader_variant == ShaderVariant::NORMAL)
        {
            if (material->m_material_type == KCL::Material::SKY)
            {
                m_vert_consts.mvp2 = sm->m_world_pom * camera->GetViewProjectionOrigo();
            }
            else
            {
                m_vert_consts.mvp2 = sm->m_prev_world_pom * m_prev_vp;
            }
        }
        
        m_frag_consts.dpcam_view = m_dpcam.GetView();
        
        // cascaded_shadow_matrices
        for (KCL::uint32 i = 0; i < CASCADE_COUNT; ++i)
        {
            m_frag_consts.cascaded_shadow_matrices[i] = m_cascaded_shadow_map->GetShadowMatrices()[i];
        }
        
        // cascaded_frustum_distances
        m_frag_consts.cascaded_frustum_distances = m_cascaded_shadow_map->GetFrustumDistances();

		//Set pipeline
		if (prev_material != material || prev_shader_variant != shader_variant || override_material)
		{
			texture_num_from_material = 0;
			material->SetPipelineAndTextures(renderInfo, pass_type, shader_variant, texture_num_from_material);
		}

        prev_material = material;
        prev_shader_variant = shader_variant;
        
        if (is_instanced_draw)
        {
			if (renderInfo.occlusionCull)
			{
				off_t dataOffset = (m_occlusion_cull->GetInstanceBufferOffset() + sm->m_mio2->m_indirect_draw_id) * sizeof(GFXB4::Mesh3::InstanceData) * MAX_INSTANCES;
				renderInfo.instanceDataOffset = dataOffset;
			}
			else
			{
				renderInfo.instanceDataOffset = g_instanceDataOffset;
				g_instanceDataOffset += sizeof(GFXB4::Mesh3::InstanceData) * sm->m_num_visible_instances;
			}
        }

        renderInfo.tessellate = material->m_is_tesselated && pass_type != KRL_Scene::PassType::REFLECTION;

        renderInfo.fragmentTextures[ENVMAP1_DP_SLOT] = m_dynamic_cubemaps[0]->GetTexture();
        renderInfo.fragmentTextures[ENVMAP2_DP_SLOT] = m_dynamic_cubemaps[1]->GetTexture();

		for (KCL::uint32 i = 0; i < NUM_STATIC_ENVMAPS; ++i)
        {
			renderInfo.fragmentTextures[STATIC_ENVMAPS_SLOT_0 + i] = static_cast<MetalRender::Texture *>(m_static_cubemaps[i])->GetTexture();
        }
        
        renderInfo.fragmentSamplers[STATIC_ENVMAPS_SLOT_0] = m_cubemap_sampler;

        renderInfo.fragmentTextures[CASCADED_SHADOW_TEXTURE_ARRAY_SLOT] = m_cascaded_shadow_map->GetTexture();
		renderInfo.fragmentSamplers[CASCADED_SHADOW_TEXTURE_ARRAY_SLOT] = m_cascaded_shadow_map->GetSampler();
        
        renderInfo.vertexOffsets[0] = 0;
        renderInfo.vertexOffsets[VERTEX_CONSTANTS_SLOT] = m_dynamic_data_buffer->WriteDataAndGetOffset(nil, &m_vert_consts, sizeof(VertexConstants));
        renderInfo.vertexOffsets[TESSELLATION_CONSTANTS_SLOT] = m_dynamic_data_buffer->WriteDataAndGetOffset(nil, &m_tess_consts, sizeof(TessellationConstants));
        
        renderInfo.fragmentOffsets[FRAME_CONSTANTS_SLOT] = GetFrameConstsOffset();
        renderInfo.fragmentOffsets[FRAGMENT_CONSTANTS_SLOT] = m_dynamic_data_buffer->WriteDataAndGetOffset(nil, &m_frag_consts, sizeof(FragmentConstants));
        renderInfo.glbMesh3 = dynamic_cast<GFXB4::Mesh3*>(selected_mesh);
        renderInfo.sm = sm;
        renderInfo.lod = lod;

        auto oldCullMode = renderInfo.cullMode;
        if ((pass_type == PassType::REFLECTION) && (slice_id == 1) && (material->m_material_type != KCL::Material::SKY))
        {
            renderInfo.cullMode = MTLCullModeFront;
        }
        
        g_renderList.emplace_back(renderInfo);
        renderInfo.cullMode = oldCullMode;

		sm->m_materials[RENDER_MATERIAL_ID] = NULL;
	}
}

void MTL_Scene_40::EndEncodeRender(__strong id<MTLCommandBuffer>& command_buffer,
                          std::function<id<MTLRenderCommandEncoder>(id<MTLCommandBuffer>)> createEncoder,
                          bool occlusion_cull, bool tessellation)
{
	if (tessellation)
	{
		static const TessFactor allOne =
		{
			{ 1, 1, 1, 1 },
			{ 1, 1, 1, 1 }
		};
		
		m_tessellator->ResetTessellator();
		
		id<MTLComputeCommandEncoder> computeEncoder = [command_buffer computeCommandEncoder];
		computeEncoder.label = @"Compute Tessellation Factors";

		if (m_occlusion_cull_tessellated_enabled)
		{
			[computeEncoder setBuffer:m_dynamic_data_buffer->GetCurrentBuffer() offset:g_occlusionDataOffset atIndex:OCCLUSION_UNIFORMS_SLOT];
			[computeEncoder setTexture:m_occlusion_cull->GetHiZDepthTexture() atIndex:HIZ_TEXTURE_SLOT];
			[computeEncoder setSamplerState:m_occlusion_cull->GetHiZDepthSampler() atIndex:HIZ_TEXTURE_SLOT];
		}
		
		m_tessellator->ResetContextId();

		for(const auto& renderInfo : g_renderList)
		{
			if (!renderInfo.tessellate)
				continue;
			
			const auto lod = renderInfo.lod;

			[computeEncoder setBuffer:m_dynamic_data_buffer->GetCurrentBuffer()
							   offset:renderInfo.vertexOffsets[VERTEX_CONSTANTS_SLOT]
							  atIndex:VERTEX_CONSTANTS_SLOT];
			
			if (renderInfo.occlusionCull)
			{
				[computeEncoder setBuffer:m_occlusion_cull->GetInstanceBuffer()
								   offset:renderInfo.instanceDataOffset
								  atIndex:INSTANCE_CONSTANTS_SLOT];
			}
			else
			{
				[computeEncoder setBuffer:m_dynamic_data_buffer->GetCurrentBuffer()
								   offset:renderInfo.instanceDataOffset
								  atIndex:INSTANCE_CONSTANTS_SLOT];
			}

			[computeEncoder setBuffer:m_dynamic_data_buffer->GetCurrentBuffer()
							   offset:renderInfo.vertexOffsets[TESSELLATION_CONSTANTS_SLOT]
							  atIndex:TESSELLATION_CONSTANTS_SLOT];

			[computeEncoder setBuffer:renderInfo.glbMesh3->GetVertexBuffer()
							   offset:0
							  atIndex:VERTEX_BUFFER_SLOT];

			[computeEncoder setBuffer:renderInfo.glbMesh3->GetIndexBuffer(lod)
							   offset:(NSUInteger)renderInfo.sm->m_mesh->m_ebo[lod].m_offset
							  atIndex:INDEX_BUFFER_SLOT];

			if (renderInfo.sm->m_mio2)
			{
				renderInfo.preparePipeline->SetAsCompute(computeEncoder);
				
				if (renderInfo.useConstantOne)
				{
					m_tessellator->PrepareIndexedPrimitives(computeEncoder, renderInfo.preparePipeline->GetThreadExecutionWidth(),
															KCL::uint32(renderInfo.sm->m_mesh->getIndexCount(lod)),
															renderInfo.sm->m_mesh->m_num_patch_vertices, renderInfo.sm->m_num_visible_instances, allOne, true);
				}
				else
				{
					m_tessellator->PrepareIndexedPrimitives(computeEncoder, renderInfo.preparePipeline->GetThreadExecutionWidth(),
															KCL::uint32(renderInfo.sm->m_mesh->getIndexCount(lod)),
															renderInfo.sm->m_mesh->m_num_patch_vertices, renderInfo.sm->m_num_visible_instances, true);
				}
			}
			else
			{
				assert(renderInfo.sm->m_num_visible_instances == 0);
				renderInfo.preparePipeline->SetAsCompute(computeEncoder);

				if (renderInfo.useConstantOne)
				{
					m_tessellator->PrepareIndexedPrimitives(computeEncoder, renderInfo.preparePipeline->GetThreadExecutionWidth(),
															KCL::uint32(renderInfo.sm->m_mesh->getIndexCount(lod)),
															renderInfo.sm->m_mesh->m_num_patch_vertices, 1, allOne, false);
				}
				else
				{
					m_tessellator->PrepareIndexedPrimitives(computeEncoder, renderInfo.preparePipeline->GetThreadExecutionWidth(),
															KCL::uint32(renderInfo.sm->m_mesh->getIndexCount(lod)),
															renderInfo.sm->m_mesh->m_num_patch_vertices, 1, false);
				}
			}
		}
		
		[computeEncoder endEncoding];
	}
    
    id<MTLRenderCommandEncoder> encoder = createEncoder(command_buffer);
    
    [encoder setVertexBuffer:m_dynamic_data_buffer->GetCurrentBuffer() offset:0 atIndex:VERTEX_CONSTANTS_SLOT];
    [encoder setVertexBuffer:m_dynamic_data_buffer->GetCurrentBuffer() offset:0 atIndex:INSTANCE_CONSTANTS_SLOT];
    [encoder setVertexBuffer:m_dynamic_data_buffer->GetCurrentBuffer() offset:0 atIndex:TESSELLATION_CONSTANTS_SLOT];
    
    [encoder setFragmentBuffer:m_dynamic_data_buffer->GetCurrentBuffer() offset:0 atIndex:FRAME_CONSTANTS_SLOT];
    [encoder setFragmentBuffer:m_dynamic_data_buffer->GetCurrentBuffer() offset:0 atIndex:FRAGMENT_CONSTANTS_SLOT];

    m_tessellator->ResetContextId();

    // Actually render stuff
    for(const auto& renderInfo : g_renderList)
    {
        auto primitive_type = MTLPrimitiveTypeTriangle;
        const auto lod = renderInfo.lod;
        const auto sm = renderInfo.sm;
        
        renderInfo.renderPipeline->Set(encoder);
        
        [encoder setDepthStencilState:renderInfo.depthStencil];
        [encoder setCullMode:renderInfo.cullMode];

        for(int i = 1; i < 4; i++)
            [encoder setVertexBufferOffset:renderInfo.vertexOffsets[i] atIndex:i];

        for(int i = 0; i < 2; i++)
            [encoder setFragmentBufferOffset:renderInfo.fragmentOffsets[i] atIndex:i];

        [encoder setVertexTexture:renderInfo.fragmentTextures[0] atIndex:0];

		if (renderInfo.fragmentSamplers[0])
			[encoder setVertexSamplerState:renderInfo.fragmentSamplers[0] atIndex:0];

        [encoder setFragmentTextures:renderInfo.fragmentTextures withRange:NSMakeRange(0, 22)];

		for (int i = 0; i < 16; ++i)
		{
			if (renderInfo.fragmentSamplers[i])
				[encoder setFragmentSamplerState:renderInfo.fragmentSamplers[i] atIndex:i];
		}

		if (renderInfo.tessellate)
		{
			if (sm->m_mio2)
			{
				if (renderInfo.occlusionCull)
				{
					[encoder setVertexBuffer:m_occlusion_cull->GetInstanceBuffer()
									  offset:renderInfo.instanceDataOffset
									 atIndex:INSTANCE_CONSTANTS_SLOT];
				}
				else
				{
					[encoder setVertexBuffer: m_dynamic_data_buffer->GetCurrentBuffer()
									  offset:renderInfo.instanceDataOffset
									 atIndex:INSTANCE_CONSTANTS_SLOT];
				}
			}

			[encoder setVertexBuffer:renderInfo.glbMesh3->GetIndexBuffer(lod)
							  offset:(NSUInteger)renderInfo.sm->m_mesh->m_ebo[lod].m_offset
							 atIndex:INDEX_BUFFER_SLOT];

			[encoder setVertexBuffer:renderInfo.glbMesh3->GetVertexBuffer()
							  offset: 0
							 atIndex:VERTEX_BUFFER_SLOT];

			m_tessellator->IssueDraw(encoder, renderInfo.glbMesh3->GetIndexBuffer(lod), (NSUInteger)renderInfo.sm->m_mesh->m_ebo[lod].m_offset);
		}
		else
		{
			[encoder setVertexBuffer:renderInfo.glbMesh3->GetVertexBuffer() offset:0 atIndex:0];

			if (sm->m_mio2)
			{
				if (renderInfo.occlusionCull)
				{
					[encoder setVertexBuffer:m_occlusion_cull->GetInstanceBuffer()
									  offset:renderInfo.instanceDataOffset
									 atIndex:INSTANCE_CONSTANTS_SLOT];

					[encoder drawIndexedPrimitives:primitive_type
										 indexType:MTLIndexTypeUInt16
									   indexBuffer:renderInfo.glbMesh3->GetIndexBuffer(lod)
								 indexBufferOffset:(NSUInteger)renderInfo.sm->m_mesh->m_ebo[lod].m_offset
									indirectBuffer:m_occlusion_cull->GetIndirectCommandBuffer()
							  indirectBufferOffset:sm->m_mio2->m_indirect_draw_id * sizeof(MTLDrawIndexedPrimitivesIndirectArguments)];
				}
				else
				{
					[encoder setVertexBuffer: m_dynamic_data_buffer->GetCurrentBuffer()
									  offset:renderInfo.instanceDataOffset
									 atIndex:INSTANCE_CONSTANTS_SLOT];

					[encoder drawIndexedPrimitives:primitive_type
										indexCount:KCL::uint32(renderInfo.glbMesh3->getIndexCount(lod))
										 indexType:MTLIndexTypeUInt16
									   indexBuffer:renderInfo.glbMesh3->GetIndexBuffer(lod)
								 indexBufferOffset:(NSUInteger)renderInfo.glbMesh3->m_ebo[lod].m_offset
									 instanceCount:sm->m_num_visible_instances];
				}
			}
			else
			{
				[encoder drawIndexedPrimitives:primitive_type
									indexCount:KCL::uint32(renderInfo.glbMesh3->getIndexCount(lod))
									 indexType:MTLIndexTypeUInt16
								   indexBuffer:renderInfo.glbMesh3->GetIndexBuffer(lod)
							 indexBufferOffset:(NSUInteger)renderInfo.sm->m_mesh->m_ebo[lod].m_offset];
			}
		}
	}

    [encoder endEncoding];
}


void MTL_Scene_40::Animate()
{
	// Calculate the delta time. It can be negative
	KCL::int32 delta_time;
	if (m_last_animation_time < 0)
	{
		// Ensure first frame delta time is zero even during single frame rendering
		delta_time = 0;
	}
	else
	{
		delta_time = m_animation_time - m_last_animation_time;
	}

	bool paused = m_last_animation_time == m_animation_time;

	m_last_animation_time = m_animation_time;

	// Set the sun direction according to the animation time
	// (Times of the second camera shot)
	if ((m_animation_time >= 5000) && (m_animation_time < 7209))
	{
		m_light_dir = KCL::Vector3D(-0.984f, 0.1736f, 0.0f).normalize();
	}
	else
	{
		m_light_dir = m_light_dir_orig;
	}

	if (m_HDR_exposure && !paused)
	{
		KCL::Vector4D result;
		float time = m_animation_time / 1000.0f;
		float time_base = 0;
		_key_node::Get(result, m_HDR_exposure, time, time_base, false);
		m_frame_consts.exposure_bloomthreshold_tone_map_white_pad.x = result.x;
	}

	//calculate tone map for linear white

	KCL::Vector4D ABCD = m_frame_consts.ABCD;
	KCL::Vector4D EFW_tau = m_frame_consts.EFW_tau;
	const float& A = ABCD.x; // ShoulderStrength;
	const float& B = ABCD.y; // LinearStrength;
	const float& C = ABCD.z; // LinearAngle;
	const float& D = ABCD.w; // ToeStrength;

	const float& E = EFW_tau.x; // ToeNumerator;
	const float& F = EFW_tau.y; // ToeDenominator;
	const float& W = EFW_tau.z; //LinearWhite

	m_frame_consts.exposure_bloomthreshold_tone_map_white_pad.z = ((W*(A*W+C*B)+D*E)/(W*(A*W+B)+D*F))-E/F;
	m_frame_consts.time_dt_pad2.x = m_animation_time * 0.001f;
	m_frame_consts.time_dt_pad2.y = delta_time * 0.001f; // to seconds
	m_frame_consts.global_light_dir = KCL::Vector4D(m_light_dir, 1.0);
	m_frame_consts.global_light_color = KCL::Vector4D(m_light_color * m_sunColorStrength, 1.0);
	m_frame_consts.fogCol = KCL::Vector4D(m_fogColor * m_fogColorStrength);

	// Motion blur
	uint32_t long_side_length = KCL::Max(m_viewport_width,m_viewport_height);
	const float max_velocity = float(m_compute_motion_blur->GetTileSize()) / float(long_side_length) * 1.5f;
	m_frame_consts.mb_velocity_min_max_sfactor_pad.x = 0.5f / float(long_side_length);
	m_frame_consts.mb_velocity_min_max_sfactor_pad.y = max_velocity;
	m_frame_consts.mb_velocity_min_max_sfactor_pad.z = float(m_compute_motion_blur->GetSampleCount()) / max_velocity;

	// Detect camera clip changes
	m_camera_clip_changed = false;

	KCL::int32 current_camera_clip = GetCameraClipId(m_animation_time);
	if (current_camera_clip != m_prev_camera_clip)
	{
		m_prev_camera_clip = current_camera_clip;
		m_camera_clip_changed = true;
		m_prev_mvp_valid = false;
	}
	else
	{
		// Check if the prev model-view-projection matrices are valid. (Used by Motion Blur)
		// The prev MVP matrices are calculated during the animation of the scene by using time = m_animation_time - 5.
		// (See KCL::SceneHandler::Animate() for details.)
		KCL::int32 prev_mvp_clip = GetCameraClipId(m_animation_time - 5);
		m_prev_mvp_valid = (prev_mvp_clip == current_camera_clip);
	}

	KRL_Scene::Animate();
}

KCL::int32 MTL_Scene_40::GetCameraClipId(KCL::int32 time)
{
	if (time < 0)
	{
		return -1;
	}

	KCL::Vector4D r;
	float time_seconds = time * m_animation_multiplier * 0.001f;
	float time_base = 0.0f;

	KCL::_key_node::Get(r, m_camera_cut_track, time_seconds, time_base);
	return KCL::int32(r.x);
}

void MTL_Scene_40::CollectInstances(unsigned flags, std::vector<GFXB4::Mesh3::InstanceData> &instance_data, std::vector<KCL::Mesh*> &instances, const std::vector<KCL::MeshInstanceOwner2*> &visible_mios)
{
	instances.reserve( visible_mios.size());

	for( size_t i=0; i<visible_mios.size(); i++)
	{
        if (visible_mios[i]->m_material->m_is_transparent && !(flags & CollectionFlags::CollectTransparent)) //[APPL-INSTANCING]
            continue;
        
        if (!visible_mios[i]->m_material->m_is_transparent && !(flags & CollectionFlags::CollectOpaque))
            continue;
        
		visible_mios[i]->m_visible_instances[0]->m_num_visible_instances = visible_mios[i]->m_visible_instances.size();
        
		for( size_t j=0; j<visible_mios[i]->m_visible_instances.size(); j++)
		{
			KCL::Mesh *m = visible_mios[i]->m_visible_instances[j];

			KRL::Mesh3::InstanceData id;

			KCL::Matrix4x4 mat = m->m_world_pom;
			if (m->m_material->m_is_billboard) //billboards shall only have the translation part
			{
				mat = KCL::Matrix4x4();
				mat.v41 = m->m_world_pom.v41; mat.v42 = m->m_world_pom.v42; mat.v43 = m->m_world_pom.v43;
			}
			id.mv = mat;

			KCL::Matrix4x4::InvertModelView( id.mv, id.inv_mv);

			instance_data.push_back( id);
		}

        instances.push_back(visible_mios[i]->m_visible_instances[0]);
	}
}


void MTL_Scene_40::CollectInstances(unsigned flags, std::vector<GFXB4::Mesh3::InstanceData> &instance_data, std::vector<KCL::Mesh*> &instances, const std::vector< std::vector<KCL::Mesh*> > &visible_instances)
{
	instances.reserve( visible_instances.size());

	for( size_t i=0; i<visible_instances.size(); i++)
	{
        if (visible_instances[i][0]->m_material->m_is_transparent && !(flags & CollectionFlags::CollectTransparent)) //[APPL-INSTANCING]
            continue;
        
        if (!visible_instances[i][0]->m_material->m_is_transparent && !(flags & CollectionFlags::CollectOpaque))
            continue;
        
		visible_instances[i][0]->m_num_visible_instances = visible_instances[i].size();

		for( size_t j=0; j<visible_instances[i].size(); j++)
		{
			KCL::Mesh *m = visible_instances[i][j];

			KRL::Mesh3::InstanceData id;

			KCL::Matrix4x4 mat = m->m_world_pom;
            
            
			if (m->m_material->m_is_billboard) //billboards shall only have the translation part
			{
				mat = KCL::Matrix4x4();
				mat.v41 = m->m_world_pom.v41; mat.v42 = m->m_world_pom.v42; mat.v43 = m->m_world_pom.v43;
			}
			id.mv = mat;

			KCL::Matrix4x4::InvertModelView( id.mv, id.inv_mv);

			instance_data.push_back( id);
		}
        
        instances.push_back(visible_instances[i][0]);
	}
}


void MTL_Scene_40::CollectRenderMaterials(std::vector<KCL::Mesh*> &meshes, KCL::Material *override_material, PassType::Enum pass_type, KCL::uint32 slice_id)
{
	for (size_t i = 0; i < meshes.size(); i++)
	{
		KCL::Mesh *mesh = meshes[i];
		KCL::Material *material = mesh->m_material;

		if (override_material)
		{
			if (pass_type == PassType::SHADOW)
			{
				if (material->m_is_billboard)
				{
					m_transparent_billboard_shadow_material->m_textures[0] = material->m_textures[0];
					material = m_transparent_billboard_shadow_material;
				}
				else if (material->m_displacement_mode == KCL::Material::DISPLACEMENT_ABS && slice_id < 2)
				{
					// Do not tesselate in far cascades
					m_tessellated_shadow_material->m_textures[0] = material->m_textures[0];
					material = m_tessellated_shadow_material;
				}
				else if (material->m_opacity_mode == KCL::Material::ALPHA_TEST)
				{
					m_transparent_shadow_material->m_textures[0] = material->m_textures[0];
					material = m_transparent_shadow_material;
				}
				else
				{
					override_material->m_textures[0] = material->m_textures[0];
					material = override_material;
				}
			}
			else
			{
				override_material->m_textures[0] = material->m_textures[0];
				material = override_material;
			}
		}
		mesh->m_materials[RENDER_MATERIAL_ID] = material;
	}
}


void MTL_Scene_40::CollectRenderMaterials(std::vector<KCL::MeshInstanceOwner2*> &visible_mios, KCL::Material *override_material, PassType::Enum pass_type, KCL::uint32 slice_id)
{
	for (size_t i = 0; i < visible_mios.size(); i++)
	{
		KCL::Mesh *mesh = visible_mios[i]->m_visible_instances[0];
		KCL::Material *material = mesh->m_material;

		if (override_material)
		{
			if (pass_type == PassType::SHADOW)
			{
				if (material->m_is_billboard)
				{
					m_transparent_billboard_shadow_material->m_textures[0] = material->m_textures[0];
					material = m_transparent_billboard_shadow_material;
				}
				else if (material->m_displacement_mode == KCL::Material::DISPLACEMENT_ABS && slice_id < 2)
				{
					// Do not tesselate in far cascades
					m_tessellated_shadow_material->m_textures[0] = material->m_textures[0];
					material = m_tessellated_shadow_material;
				}
				else if (material->m_opacity_mode == KCL::Material::ALPHA_TEST)
				{
					m_transparent_shadow_material->m_textures[0] = material->m_textures[0];
					material = m_transparent_shadow_material;
				}
				else
				{
					override_material->m_textures[0] = material->m_textures[0];
					material = override_material;
				}
			}
			else
			{
				override_material->m_textures[0] = material->m_textures[0];
				material = override_material;
			}
		}
		mesh->m_materials[RENDER_MATERIAL_ID] = material;

	}
}

KCL::Texture* MTL_Scene_40::GetTopdownShadowMap() const
{
	return m_topdown_shadow;
}

id<MTLSamplerState> MTL_Scene_40::GetTopdownShadowSampler() const
{
	return m_topdown_shadow_sampler;
}

id<MTLTexture> MTL_Scene_40::GetVelocityBuffer() const
{
	return m_gbuffer->GetVelocityTexture();
}
